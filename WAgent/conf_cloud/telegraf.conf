# Telegraf Configuration
#
# Telegraf is entirely plugin driven. All metrics are gathered from the
# declared inputs, and sent to the declared outputs.
#
# Plugins must be declared in here to be active.
# To deactivate a plugin, comment out the name and any variables.
#
# Use 'telegraf -config telegraf.conf -test' to see what metrics a config
# file would generate.
#
# Environment variables can be used anywhere in this config file, simply surround
# them with ${}. For strings the variable must be within quotes (ie, "${STR_VAR}"),
# for numbers and booleans they should be plain (ie, ${INT_VAR}, ${BOOL_VAR})


# Global tags can be specified here in key="value" format.
[global_tags]
  dc = "Cloud" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"

# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  interval = "10s"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = true

  ## Telegraf will send metrics to outputs in batches of at most
  ## metric_batch_size metrics.
  ## This controls the size of writes that Telegraf sends to output plugins.
  metric_batch_size = 1000

  ## Maximum number of unwritten metrics per output.  Increasing this value
  ## allows for longer periods of output downtime without dropping metrics at the
  ## cost of higher maximum memory usage.
  metric_buffer_limit = 10000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Collection offset is used to shift the collection by the given amount.
  ## This can be be used to avoid many plugins querying constraint devices
  ## at the same time by manually scheduling them in time.
  # collection_offset = "0s"

  ## Default flushing interval for all outputs. Maximum flush_interval will be
  ## flush_interval + flush_jitter
  flush_interval = "10s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "0s"

  ## Collected metrics are rounded to the precision specified. Precision is
  ## specified as an interval with an integer + unit (e.g. 0s, 10ms, 2us, 4s).
  ## Valid time units are "ns", "us" (or "Âµs"), "ms", "s".
  ##
  ## By default or when set to "0s", precision will be set to the same
  ## timestamp order as the collection interval, with the maximum being 1s:
  ##   ie, when interval = "10s", precision will be "1s"
  ##       when interval = "250ms", precision will be "1ms"
  ##
  ## Precision will NOT be used for service inputs. It is up to each individual
  ## service input to set the timestamp at the appropriate precision.
  precision = "0s"

  ## Log at debug level.
  # debug = false
  ## Log only error level messages.
  # quiet = false

  ## Log target controls the destination for logs and can be one of "file",
  ## "stderr" or, on Windows, "eventlog".  When set to "file", the output file
  ## is determined by the "logfile" setting.
  # logtarget = "file"

  ## Name of the file to be logged to when using the "file" logtarget.  If set to
  ## the empty string then logs are written to stderr.
  # logfile = ""

  ## The logfile will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.  Logs are rotated only when
  ## written to, if there is no log activity rotation may be delayed.
  # logfile_rotation_interval = "0h"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # logfile_rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # logfile_rotation_max_archives = 5

  ## Pick a timezone to use when logging or type 'local' for local time.
  ## Example: America/Chicago
  # log_with_timezone = ""

  ## Override default hostname, if empty use os.Hostname()
  hostname = "${COMPUTERNAME}"
  ## If set to true, do no set the "host" tag in the telegraf agent.
  omit_hostname = false

  ## Method of translating SNMP objects. Can be "netsnmp" (deprecated) which
  ## translates by calling external programs snmptranslate and snmptable,
  ## or "gosmi" which translates using the built-in gosmi library.
  # snmp_translator = "netsnmp"

  ## Name of the file to load the state of plugins from and store the state to.
  ## If uncommented and not empty, this file will be used to save the state of
  ## stateful plugins on termination of Telegraf. If the file exists on start,
  ## the state in the file will be restored for the plugins.
  # statefile = ""

###############################################################################
#                            SECRETSTORE PLUGINS                              #
###############################################################################


# # Secret-store to access Docker Secrets
# [[secretstores.docker]]
#   ## Unique identifier for the secretstore.
#   ## This id can later be used in plugins to reference the secrets
#   ## in this secret-store via @{<id>:<secret_key>} (mandatory)
#   id = "docker_secretstore"
#
#   ## Default Path to directory where docker stores the secrets file
#   ## Current implementation in docker compose v2 only allows the following
#   ## value for the path where the secrets are mounted at runtime
#   # path = "/run/secrets"
#
#   ## Allow dynamic secrets that are updated during runtime of telegraf
#   ## Dynamic Secrets work only with `file` or `external` configuration
#   ## in `secrets` section of the `docker-compose.yml` file
#   # dynamic = false


# # Read secrets from a HTTP endpoint
# [[secretstores.http]]
#   ## Unique identifier for the secret-store.
#   ## This id can later be used in plugins to reference the secrets
#   ## in this secret-store via @{<id>:<secret_key>} (mandatory)
#   id = "secretstore"
#
#   ## URLs from which to read the secrets
#   url = "http://localhost/secrets"
#
#   ## Optional HTTP headers
#   # headers = {"X-Special-Header" = "Special-Value"}
#
#   ## Optional Token for Bearer Authentication via
#   ## "Authorization: Bearer <token>" header
#   # token = "your-token"
#
#   ## Optional Credentials for HTTP Basic Authentication
#   # username = "username"
#   # password = "pa$$word"
#
#   ## OAuth2 Client Credentials. The options 'client_id', 'client_secret', and 'token_url' are required to use OAuth2.
#   # client_id = "clientid"
#   # client_secret = "secret"
#   # token_url = "https://indentityprovider/oauth2/v1/token"
#   # scopes = ["urn:opc:idm:__myscopes__"]
#
#   ## HTTP Proxy support
#   # use_system_proxy = false
#   # http_proxy_url = ""
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Minimal TLS version to accept by the client
#   # tls_min_version = "TLS12"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Optional Cookie authentication
#   # cookie_auth_url = "https://localhost/authMe"
#   # cookie_auth_method = "POST"
#   # cookie_auth_username = "username"
#   # cookie_auth_password = "pa$$word"
#   # cookie_auth_headers = { Content-Type = "application/json", X-MY-HEADER = "hello" }
#   # cookie_auth_body = '{"username": "user", "password": "pa$$word", "authenticate": "me"}'
#   ## When unset or set to zero the authentication will only happen once
#   ## and will never renew the cookie. Set to a suitable duration if you
#   ## require cookie renewal!
#   # cookie_auth_renewal = "0s"
#
#   ## Amount of time allowed to complete the HTTP request
#   # timeout = "5s"
#
#   ## List of success status codes
#   # success_status_codes = [200]
#
#   ## JSONata expression to transform the server response into a
#   ##   { "secret name": "secret value", ... }
#   ## form. See https://jsonata.org for more information and a playground.
#   # transformation = ''
#
#   ## Cipher used to decrypt the secrets.
#   ## In case your secrets are transmitted in an encrypted form, you need
#   ## to specify the cipher used and provide the corresponding configuration.
#   ## Please refer to https://github.com/influxdata/telegraf/blob/master/plugins/secretstores/http/README.md
#   ## for supported values.
#   # cipher = "none"
#
#   ## AES cipher parameters
#   # [secretstores.http.aes]
#   #   ## Key (hex-encoded) and initialization-vector (IV) for the decryption.
#   #   ## In case the key (and IV) is derived from a password, the values can
#   #   ## be omitted.
#   #   key = ""
#   #   init_vector = ""
#   #
#   #   ## Parameters for password-based-key derivation.
#   #   ## These parameters must match the encryption side to derive the same
#   #   ## key on both sides!
#   #   # kdf_algorithm = "PBKDF2-HMAC-SHA256"
#   #   # password = ""
#   #   # salt = ""
#   #   # iterations = 0


# # File based Javascript Object Signing and Encryption based secret-store
# [[secretstores.jose]]
#   ## Unique identifier for the secret-store.
#   ## This id can later be used in plugins to reference the secrets
#   ## in this secret-store via @{<id>:<secret_key>} (mandatory)
#   id = "secretstore"
#
#   ## Directory for storing the secrets
#   path = "/etc/telegraf/secrets"
#
#   ## Password to access the secrets.
#   ## If no password is specified here, Telegraf will prompt for it at startup time.
#   # password = ""


# # Operating System native secret-store
# [[secretstores.os]]
#   ## Unique identifier for the secret-store.
#   ## This id can later be used in plugins to reference the secrets
#   ## in this secret-store via @{<id>:<secret_key>} (mandatory)
#   id = "secretstore"
#
#   ## Keyring Name & Collection
#   ## * Linux: keyring name used for the secrets, collection is unused
#   ## * macOS: keyring specifies the macOS' Keychain name and collection is an
#   ##     optional Keychain service name
#   ## * Windows: keys follow a fixed pattern in the form
#   ##     `<collection>:<keyring>:<key_name>`. Please keep this in mind when
#   ##     creating secrets with the Windows credential tool.
#   # keyring = "telegraf"
#   # collection = ""
#
#   ## macOS Keychain password
#   ## If no password is specified here, Telegraf will prompt for it at startup
#   ## time.
#   # password = ""
#
#   ## Allow dynamic secrets that are updated during runtime of telegraf
#   # dynamic = false


###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################




# # Configuration for sending metrics to InfluxDB
[[outputs.influxdb]]
#   ## The full HTTP or UDP URL for your InfluxDB instance.
#   ##
#   ## Multiple URLs can be specified for a single cluster, only ONE of the
#   ## urls will be written to each interval.
#   # urls = ["unix:///var/run/influxdb.sock"]
#   # urls = ["udp://127.0.0.1:8089"]
#   # urls = ["http://127.0.0.1:8086"]
  urls = ["http://192.168.30.23:8086"]
#
#   ## The target database for metrics; will be created as needed.
#   ## For UDP url endpoint database needs to be configured on server side.
#   # database = "telegraf"
  database = "Clients"
#
#   ## The value of this tag will be used to determine the database.  If this
#   ## tag is not set the 'database' option is used as the default.
#   # database_tag = ""
#
#   ## If true, the 'database_tag' will not be included in the written metric.
#   # exclude_database_tag = false
#
#   ## If true, no CREATE DATABASE queries will be sent.  Set to true when using
#   ## Telegraf with a user without permissions to create databases or when the
#   ## database already exists.
#   # skip_database_creation = false
#
#   ## Name of existing retention policy to write to.  Empty string writes to
#   ## the default retention policy.  Only takes effect when using HTTP.
#   # retention_policy = ""
#
#   ## The value of this tag will be used to determine the retention policy.  If this
#   ## tag is not set the 'retention_policy' option is used as the default.
#   # retention_policy_tag = ""
#
#   ## If true, the 'retention_policy_tag' will not be included in the written metric.
#   # exclude_retention_policy_tag = false
#
#   ## Write consistency (clusters only), can be: "any", "one", "quorum", "all".
#   ## Only takes effect when using HTTP.
#   # write_consistency = "any"
#
#   ## Timeout for HTTP messages.
#   # timeout = "5s"
#
#   ## HTTP Basic Auth
#   # username = "telegraf"
#   # password = "metricsmetricsmetricsmetrics"
  username = "telegraf"
  password = "metricsmetricsmetricsmetrics"
#
#   ## HTTP User-Agent
#   # user_agent = "telegraf"
#
#   ## UDP payload size is the maximum packet size to send.
#   # udp_payload = "512B"
#
#   ## Optional TLS Config for use on HTTP connections.
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## HTTP Proxy override, if unset values the standard proxy environment
#   ## variables are consulted to determine which proxy, if any, should be used.
#   # http_proxy = "http://corporate.proxy:3128"
#
#   ## Additional HTTP headers
#   # http_headers = {"X-Special-Header" = "Special-Value"}
#
#   ## HTTP Content-Encoding for write request body, can be set to "gzip" to
#   ## compress body or "identity" to apply no encoding.
#   # content_encoding = "gzip"
#
#   ## When true, Telegraf will output unsigned integers as unsigned values,
#   ## i.e.: "42u".  You will need a version of InfluxDB supporting unsigned
#   ## integer values.  Enabling this option will result in field type errors if
#   ## existing data has been written.
#   # influx_uint_support = false




###############################################################################
#                            PROCESSOR PLUGINS                                #
###############################################################################




###############################################################################
#                            AGGREGATOR PLUGINS                               #
###############################################################################


# # Keep the aggregate basicstats of each metric passing through.
# [[aggregators.basicstats]]
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#
#   ## Configures which basic stats to push as fields
#   # stats = ["count","diff","rate","min","max","mean","non_negative_diff","non_negative_rate","percent_change","stdev","s2","sum","interval"]


# # Calculates a derivative for every field.
# [[aggregators.derivative]]
#   ## The period in which to flush the aggregator.
#   period = "30s"
#   ##
#   ## Suffix to append for the resulting derivative field.
#   # suffix = "_rate"
#   ##
#   ## Field to use for the quotient when computing the derivative.
#   ## When using a field as the derivation parameter the name of that field will
#   ## be used for the resulting derivative, e.g. *fieldname_by_parameter*.
#   ## By default the timestamps of the metrics are used and the suffix is omitted.
#   # variable = ""
#   ##
#   ## Maximum number of roll-overs in case only one measurement is found during a period.
#   # max_roll_over = 10


# # Report the final metric of a series
# [[aggregators.final]]
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#
#   ## The time that a series is not updated until considering it final.
#   series_timeout = "5m"


# # Configuration for aggregate histogram metrics
# [[aggregators.histogram]]
#   ## The period in which to flush the aggregator.
#   period = "30s"
#
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#
#   ## If true, the histogram will be reset on flush instead
#   ## of accumulating the results.
#   reset = false
#
#   ## Whether bucket values should be accumulated. If set to false, "gt" tag will be added.
#   ## Defaults to true.
#   cumulative = true
#
#   ## Expiration interval for each histogram. The histogram will be expired if
#   ## there are no changes in any buckets for this time interval. 0 == no expiration.
#   # expiration_interval = "0m"
#
#   ## If true, aggregated histogram are pushed to output only if it was updated since
#   ## previous push. Defaults to false.
#   # push_only_on_update = false
#
#   ## Example config that aggregates all fields of the metric.
#   # [[aggregators.histogram.config]]
#   #   ## Right borders of buckets (with +Inf implicitly added).
#   #   buckets = [0.0, 15.6, 34.5, 49.1, 71.5, 80.5, 94.5, 100.0]
#   #   ## The name of metric.
#   #   measurement_name = "cpu"
#
#   ## Example config that aggregates only specific fields of the metric.
#   # [[aggregators.histogram.config]]
#   #   ## Right borders of buckets (with +Inf implicitly added).
#   #   buckets = [0.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0]
#   #   ## The name of metric.
#   #   measurement_name = "diskio"
#   #   ## The concrete fields of metric
#   #   fields = ["io_time", "read_time", "write_time"]


# # Merge metrics into multifield metrics by series key
# [[aggregators.merge]]
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = true


# # Keep the aggregate min/max of each metric passing through.
# [[aggregators.minmax]]
#   ## General Aggregator Arguments:
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false


# # Keep the aggregate quantiles of each metric passing through.
# [[aggregators.quantile]]
#   ## General Aggregator Arguments:
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#
#   ## Quantiles to output in the range [0,1]
#   # quantiles = [0.25, 0.5, 0.75]
#
#   ## Type of aggregation algorithm
#   ## Supported are:
#   ##  "t-digest" -- approximation using centroids, can cope with large number of samples
#   ##  "exact R7" -- exact computation also used by Excel or NumPy (Hyndman & Fan 1996 R7)
#   ##  "exact R8" -- exact computation (Hyndman & Fan 1996 R8)
#   ## NOTE: Do not use "exact" algorithms with large number of samples
#   ##       to not impair performance or memory consumption!
#   # algorithm = "t-digest"
#
#   ## Compression for approximation (t-digest). The value needs to be
#   ## greater or equal to 1.0. Smaller values will result in more
#   ## performance but less accuracy.
#   # compression = 100.0


# # Aggregate metrics using a Starlark script
# [[aggregators.starlark]]
#   ## The Starlark source can be set as a string in this configuration file, or
#   ## by referencing a file containing the script.  Only one source or script
#   ## should be set at once.
#   ##
#   ## Source of the Starlark script.
#   source = '''
# state = {}
#
# def add(metric):
#   state["last"] = metric
#
# def push():
#   return state.get("last")
#
# def reset():
#   state.clear()
# '''
#
#   ## File containing a Starlark script.
#   # script = "/usr/local/bin/myscript.star"
#
#   ## The constants of the Starlark script.
#   # [aggregators.starlark.constants]
#   #   max_size = 10
#   #   threshold = 0.75
#   #   default_name = "Julia"
#   #   debug_mode = true


# # Count the occurrence of values in fields.
# [[aggregators.valuecounter]]
#   ## General Aggregator Arguments:
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#   ## The fields for which the values will be counted
#   fields = ["status"]


###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################


# Read metrics about cpu usage
[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = true
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states
  report_active = false
  ## If true and the info is available then add core_id and physical_id tags
  core_tags = false


# Read metrics about disk usage by mount point
[[inputs.disk]]
  ## By default stats will be gathered for all mount points.
  ## Set mount_points will restrict the stats to only the specified mount points.
  # mount_points = ["/"]

  ## Ignore mount points by filesystem type.
  ignore_fs = ["tmpfs", "devtmpfs", "devfs", "iso9660", "overlay", "aufs", "squashfs"]

  ## Ignore mount points by mount options.
  ## The 'mount' command reports options of all mounts in parathesis.
  ## Bind mounts can be ignored with the special 'bind' option.
  # ignore_mount_opts = []


# Read metrics about disk IO by device
[[inputs.diskio]]
  ## By default, telegraf will gather stats for all devices including
  ## disk partitions.
  ## Setting devices will restrict the stats to the specified devices.
  ## NOTE: Globbing expressions (e.g. asterix) are not supported for
  ##       disk synonyms like '/dev/disk/by-id'.
  # devices = ["sda", "sdb", "vd*", "/dev/disk/by-id/nvme-eui.00123deadc0de123"]
  ## Uncomment the following line if you need disk serial numbers.
  # skip_serial_number = false
  #
  ## On systems which support it, device metadata can be added in the form of
  ## tags.
  ## Currently only Linux is supported via udev properties. You can view
  ## available properties for a device by running:
  ## 'udevadm info -q property -n /dev/sda'
  ## Note: Most, but not all, udev properties can be accessed this way. Properties
  ## that are currently inaccessible include DEVTYPE, DEVNAME, and DEVPATH.
  # device_tags = ["ID_FS_TYPE", "ID_FS_USAGE"]
  #
  ## Using the same metadata source as device_tags, you can also customize the
  ## name of the device via templates.
  ## The 'name_templates' parameter is a list of templates to try and apply to
  ## the device. The template may contain variables in the form of '$PROPERTY' or
  ## '${PROPERTY}'. The first template which does not contain any variables not
  ## present for the device is used as the device name tag.
  ## The typical use case is for LVM volumes, to get the VG/LV name instead of
  ## the near-meaningless DM-0 name.
  # name_templates = ["$ID_FS_LABEL","$DM_VG_NAME/$DM_LV_NAME"]


# Get kernel statistics from /proc/stat
# This plugin ONLY supports Linux
#![[inputs.kernel]]
  # no configuration


# Read metrics about memory usage
[[inputs.mem]]
  # no configuration


# Get the number of processes and group them by status
# This plugin ONLY supports non-Windows
#![[inputs.processes]]
  ## Use sudo to run ps command on *BSD systems. Linux systems will read
  ## /proc, so this does not apply there.
  #!use_sudo = false


# Read metrics about swap memory usage
[[inputs.swap]]
  # no configuration


# Read metrics about system load & uptime
[[inputs.system]]
  # no configuration


# # Gather ActiveMQ metrics
# [[inputs.activemq]]
#   ## ActiveMQ WebConsole URL
#   url = "http://127.0.0.1:8161"
#
#   ## Required ActiveMQ Endpoint
#   ##   deprecated in 1.11; use the url option
#   # server = "192.168.50.10"
#   # port = 8161
#
#   ## Credentials for basic HTTP authentication
#   # username = "admin"
#   # password = "admin"
#
#   ## Required ActiveMQ webadmin root path
#   # webadmin = "admin"
#
#   ## Maximum time to receive response.
#   # response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false




# # Read Apache status information (mod_status)
# [[inputs.apache]]
#   ## An array of URLs to gather from, must be directed at the machine
#   ## readable version of the mod_status page including the auto query string.
#   ## Default is "http://localhost/server-status?auto".
#   urls = ["http://localhost/server-status?auto"]
#
#   ## Credentials for basic HTTP authentication.
#   # username = "myuser"
#   # password = "mypassword"
#
#   ## Maximum time to receive response.
#   # response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read formatted metrics from one or more HTTP endpoints
# [[inputs.http]]
#   ## One or more URLs from which to read formatted metrics
#   urls = [
#     "http://localhost/metrics"
#   ]
#
#   ## HTTP method
#   # method = "GET"
#
#   ## Optional HTTP headers
#   # headers = {"X-Special-Header" = "Special-Value"}
#
#   ## HTTP entity-body to send with POST/PUT requests.
#   # body = ""
#
#   ## HTTP Content-Encoding for write request body, can be set to "gzip" to
#   ## compress body or "identity" to apply no encoding.
#   # content_encoding = "identity"
#
#   ## Optional file with Bearer token
#   ## file content is added as an Authorization header
#   # bearer_token = "/path/to/file"
#
#   ## Optional HTTP Basic Auth Credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## OAuth2 Client Credentials. The options 'client_id', 'client_secret', and 'token_url' are required to use OAuth2.
#   # client_id = "clientid"
#   # client_secret = "secret"
#   # token_url = "https://indentityprovider/oauth2/v1/token"
#   # scopes = ["urn:opc:idm:__myscopes__"]
#
#   ## HTTP Proxy support
#   # use_system_proxy = false
#   # http_proxy_url = ""
#
#   ## Optional TLS Config
#   ## Set to true/false to enforce TLS being enabled/disabled. If not set,
#   ## enable TLS only if any of the other options are specified.
#   # tls_enable =
#   ## Trusted root certificates for server
#   # tls_ca = "/path/to/cafile"
#   ## Used for TLS client certificate authentication
#   # tls_cert = "/path/to/certfile"
#   ## Used for TLS client certificate authentication
#   # tls_key = "/path/to/keyfile"
#   ## Send the specified TLS server name via SNI
#   # tls_server_name = "kubernetes.example.com"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Optional Cookie authentication
#   # cookie_auth_url = "https://localhost/authMe"
#   # cookie_auth_method = "POST"
#   # cookie_auth_username = "username"
#   # cookie_auth_password = "pa$$word"
#   # cookie_auth_headers = { Content-Type = "application/json", X-MY-HEADER = "hello" }
#   # cookie_auth_body = '{"username": "user", "password": "pa$$word", "authenticate": "me"}'
#   ## cookie_auth_renewal not set or set to "0" will auth once and never renew the cookie
#   # cookie_auth_renewal = "5m"
#
#   ## Amount of time allowed to complete the HTTP request
#   # timeout = "5s"
#
#   ## List of success status codes
#   # success_status_codes = [200]
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   # data_format = "influx"
#


# # HTTP/HTTPS request given an address a method and a timeout
# [[inputs.http_response]]
#   ## List of urls to query.
#   # urls = ["http://localhost"]
#
#   ## Set http_proxy.
#   ## Telegraf uses the system wide proxy settings if it's is not set.
#   # http_proxy = "http://localhost:8888"
#
#   ## Set response_timeout (default 5 seconds)
#   # response_timeout = "5s"
#
#   ## HTTP Request Method
#   # method = "GET"
#
#   ## Whether to follow redirects from the server (defaults to false)
#   # follow_redirects = false
#
#   ## Optional file with Bearer token
#   ## file content is added as an Authorization header
#   # bearer_token = "/path/to/file"
#
#   ## Optional HTTP Basic Auth Credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## Optional HTTP Request Body
#   # body = '''
#   # {'fake':'data'}
#   # '''
#
#   ## Optional name of the field that will contain the body of the response.
#   ## By default it is set to an empty String indicating that the body's
#   ## content won't be added
#   # response_body_field = ''
#
#   ## Maximum allowed HTTP response body size in bytes.
#   ## 0 means to use the default of 32MiB.
#   ## If the response body size exceeds this limit a "body_read_error" will
#   ## be raised.
#   # response_body_max_size = "32MiB"
#
#   ## Optional substring or regex match in body of the response (case sensitive)
#   # response_string_match = "\"service_status\": \"up\""
#   # response_string_match = "ok"
#   # response_string_match = "\".*_status\".?:.?\"up\""
#
#   ## Expected response status code.
#   ## The status code of the response is compared to this value. If they match,
#   ## the field "response_status_code_match" will be 1, otherwise it will be 0.
#   ## If the expected status code is 0, the check is disabled and the field
#   ## won't be added.
#   # response_status_code = 0
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#   ## Use the given name as the SNI server name on each URL
#   # tls_server_name = ""
#   ## TLS renegotiation method, choose from "never", "once", "freely"
#   # tls_renegotiation_method = "never"
#
#   ## HTTP Request Headers (all values must be strings)
#   # [inputs.http_response.headers]
#   #   Host = "github.com"
#
#   ## Optional setting to map response http headers into tags
#   ## If the http header is not present on the request, no corresponding tag will
#   ## be added. If multiple instances of the http header are present, only the
#   ## first value will be used.
#   # http_header_tags = {"HTTP_HEADER" = "TAG_NAME"}
#
#   ## Interface to use when dialing an address
#   # interface = "eth0"



# # Collect statistics about itself
# [[inputs.internal]]
#   ## If true, collect telegraf memory stats.
#   # collect_memstats = true


# # Monitors internet speed using speedtest.net service
# [[inputs.internet_speed]]
#   ## This plugin downloads many MB of data each time it is run. As such
#   ## consider setting a higher interval for this plugin to reduce the
#   ## demand on your internet connection.
#   # interval = "60m"
#
#   ## Enable to reduce memory usage
#   # memory_saving_mode = false
#
#   ## Caches the closest server location
#   # cache = false
#
#   ## Number of concurrent connections
#   ## By default or set to zero, the number of CPU cores is used. Use this to
#   ## reduce the impact on system performance or to increase the connections on
#   ## faster connections to ensure the fastest speed.
#   # connections = 0
#
#   ## Test mode
#   ## By default, a single sever is used for testing. This may work for most,
#   ## however, setting to "multi" will reach out to multiple servers in an
#   ## attempt to get closer to ideal internet speeds.
#   # test_mode = "single"
#
#   ## Server ID exclude filter
#   ## Allows the user to exclude or include specific server IDs received by
#   ## speedtest-go. Values in the exclude option will be skipped over. Values in
#   ## the include option are the only options that will be picked from.
#   ##
#   ## See the list of servers speedtest-go will return at:
#   ##     https://www.speedtest.net/api/js/servers?engine=js&limit=10
#   ##
#   # server_id_exclude = []
#   # server_id_include = []



# # Provides Linux CPU metrics
# # This plugin ONLY supports Linux
# [[inputs.linux_cpu]]
#   ## Path for sysfs filesystem.
#   ## See https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt
#   ## Defaults:
#   # host_sys = "/sys"
#
#   ## CPU metrics collected by the plugin.
#   ## Supported options:
#   ## "cpufreq", "thermal"
#   ## Defaults:
#   # metrics = ["cpufreq"]


# # Provides Linux sysctl fs metrics
# [[inputs.linux_sysctl_fs]]
#   # no configuration



# # Read metrics from local Lustre service on OST, MDS
# # This plugin ONLY supports Linux
# [[inputs.lustre2]]
#   ## An array of /proc globs to search for Lustre stats
#   ## If not specified, the default will work on Lustre 2.5.x
#   ##
#   # ost_procfiles = [
#   #   "/proc/fs/lustre/obdfilter/*/stats",
#   #   "/proc/fs/lustre/osd-ldiskfs/*/stats",
#   #   "/proc/fs/lustre/obdfilter/*/job_stats",
#   #   "/proc/fs/lustre/obdfilter/*/exports/*/stats",
#   # ]
#   # mds_procfiles = [
#   #   "/proc/fs/lustre/mdt/*/md_stats",
#   #   "/proc/fs/lustre/mdt/*/job_stats",
#   #   "/proc/fs/lustre/mdt/*/exports/*/stats",
#   # ]


# # Read metrics about LVM physical volumes, volume groups, logical volumes.
# [[inputs.lvm]]
#   ## Use sudo to run LVM commands
#   use_sudo = false
#
#   ## The default location of the pvs binary can be overridden with:
#   #pvs_binary = "/usr/sbin/pvs"
#
#   ## The default location of the vgs binary can be overridden with:
#   #vgs_binary = "/usr/sbin/vgs"
#
#   ## The default location of the lvs binary can be overridden with:
#   #lvs_binary = "/usr/sbin/lvs"



# # Retrieve data from MODBUS slave devices
# [[inputs.modbus]]
#   ## Connection Configuration
#   ##
#   ## The plugin supports connections to PLCs via MODBUS/TCP, RTU over TCP, ASCII over TCP or
#   ## via serial line communication in binary (RTU) or readable (ASCII) encoding
#   ##
#   ## Device name
#   name = "Device"
#
#   ## Slave ID - addresses a MODBUS device on the bus
#   ## Range: 0 - 255 [0 = broadcast; 248 - 255 = reserved]
#   slave_id = 1
#
#   ## Timeout for each request
#   timeout = "1s"
#
#   ## Maximum number of retries and the time to wait between retries
#   ## when a slave-device is busy.
#   # busy_retries = 0
#   # busy_retries_wait = "100ms"
#
#   # TCP - connect via Modbus/TCP
#   controller = "tcp://localhost:502"
#
#   ## Serial (RS485; RS232)
#   ## For RS485 specific setting check the end of the configuration.
#   ## For unix-like operating systems use:
#   # controller = "file:///dev/ttyUSB0"
#   ## For Windows operating systems use:
#   # controller = "COM1"
#   # baud_rate = 9600
#   # data_bits = 8
#   # parity = "N"
#   # stop_bits = 1
#
#   ## Transmission mode for Modbus packets depending on the controller type.
#   ## For Modbus over TCP you can choose between "TCP" , "RTUoverTCP" and
#   ## "ASCIIoverTCP".
#   ## For Serial controllers you can choose between "RTU" and "ASCII".
#   ## By default this is set to "auto" selecting "TCP" for ModbusTCP connections
#   ## and "RTU" for serial connections.
#   # transmission_mode = "auto"
#
#   ## Trace the connection to the modbus device as debug messages
#   ## Note: You have to enable telegraf's debug mode to see those messages!
#   # debug_connection = false
#
#   ## Define the configuration schema
#   ##  |---register -- define fields per register type in the original style (only supports one slave ID)
#   ##  |---request  -- define fields on a requests base
#   configuration_type = "register"
#   ## --- "register" configuration style ---
#
#   ## Measurements
#   ##
#
#   ## Digital Variables, Discrete Inputs and Coils
#   ## measurement - the (optional) measurement name, defaults to "modbus"
#   ## name        - the variable name
#   ## data_type   - the (optional) output type, can be BOOL or UINT16 (default)
#   ## address     - variable address
#
#   discrete_inputs = [
#     { name = "start",          address = [0]},
#     { name = "stop",           address = [1]},
#     { name = "reset",          address = [2]},
#     { name = "emergency_stop", address = [3]},
#   ]
#   coils = [
#     { name = "motor1_run",     address = [0]},
#     { name = "motor1_jog",     address = [1]},
#     { name = "motor1_stop",    address = [2]},
#   ]
#
#   ## Analog Variables, Input Registers and Holding Registers
#   ## measurement - the (optional) measurement name, defaults to "modbus"
#   ## name        - the variable name
#   ## byte_order  - the ordering of bytes
#   ##  |---AB, ABCD   - Big Endian
#   ##  |---BA, DCBA   - Little Endian
#   ##  |---BADC       - Mid-Big Endian
#   ##  |---CDAB       - Mid-Little Endian
#   ## data_type   - INT8L, INT8H, UINT8L, UINT8H (low and high byte variants)
#   ##               INT16, UINT16, INT32, UINT32, INT64, UINT64,
#   ##               FLOAT16-IEEE, FLOAT32-IEEE, FLOAT64-IEEE (IEEE 754 binary representation)
#   ##               FLOAT32, FIXED, UFIXED (fixed-point representation on input)
#   ## scale       - the final numeric variable representation
#   ## address     - variable address
#
#   holding_registers = [
#     { name = "power_factor", byte_order = "AB",   data_type = "FIXED", scale=0.01,  address = [8]},
#     { name = "voltage",      byte_order = "AB",   data_type = "FIXED", scale=0.1,   address = [0]},
#     { name = "energy",       byte_order = "ABCD", data_type = "FIXED", scale=0.001, address = [5,6]},
#     { name = "current",      byte_order = "ABCD", data_type = "FIXED", scale=0.001, address = [1,2]},
#     { name = "frequency",    byte_order = "AB",   data_type = "UFIXED", scale=0.1,  address = [7]},
#     { name = "power",        byte_order = "ABCD", data_type = "UFIXED", scale=0.1,  address = [3,4]},
#   ]
#   input_registers = [
#     { name = "tank_level",   byte_order = "AB",   data_type = "INT16",   scale=1.0,     address = [0]},
#     { name = "tank_ph",      byte_order = "AB",   data_type = "INT16",   scale=1.0,     address = [1]},
#     { name = "pump1_speed",  byte_order = "ABCD", data_type = "INT32",   scale=1.0,     address = [3,4]},
#   ]
#
#   ## --- "request" configuration style ---
#
#   ## Per request definition
#   ##
#
#   ## Define a request sent to the device
#   ## Multiple of those requests can be defined. Data will be collated into metrics at the end of data collection.
#   [[inputs.modbus.request]]
#     ## ID of the modbus slave device to query.
#     ## If you need to query multiple slave-devices, create several "request" definitions.
#     slave_id = 1
#
#     ## Byte order of the data.
#     ##  |---ABCD -- Big Endian (Motorola)
#     ##  |---DCBA -- Little Endian (Intel)
#     ##  |---BADC -- Big Endian with byte swap
#     ##  |---CDAB -- Little Endian with byte swap
#     byte_order = "ABCD"
#
#     ## Type of the register for the request
#     ## Can be "coil", "discrete", "holding" or "input"
#     register = "coil"
#
#     ## Name of the measurement.
#     ## Can be overriden by the individual field definitions. Defaults to "modbus"
#     # measurement = "modbus"
#
#     ## Request optimization algorithm.
#     ##  |---none       -- Do not perform any optimization and use the given layout(default)
#     ##  |---shrink     -- Shrink requests to actually requested fields
#     ##  |                 by stripping leading and trailing omits
#     ##  |---rearrange  -- Rearrange request boundaries within consecutive address ranges
#     ##  |                 to reduce the number of requested registers by keeping
#     ##  |                 the number of requests.
#     ##  |---aggressive -- Rearrange request boundaries similar to "rearrange" but
#     ##  |                 allow to request registers not specified by the user to
#     ##  |                 fill gaps. This usually reduces the number of requests at the
#     ##  |                 cost of more requested registers.
#     ##  |---max_insert -- Rearrange request keeping the number of extra fields below the value
#     ##                    provided in "optimization_max_register_fill". It is not necessary to define 'omitted'
#     ##                    fields as the optimisation will add such field only where needed.
#     # optimization = "none"
#
#     ## Maximum number register the optimizer is allowed to insert between two fields to
#     ## save requests.
#     ## This option is only used for the 'max_insert' optimization strategy.
#     ## NOTE: All omitted fields are ignored, so this option denotes the effective hole
#     ## size to fill.
#     # optimization_max_register_fill = 50
#
#     ## Field definitions
#     ## Analog Variables, Input Registers and Holding Registers
#     ## address        - address of the register to query. For coil and discrete inputs this is the bit address.
#     ## name *1        - field name
#     ## type *1,2      - type of the modbus field, can be
#     ##                  INT8L, INT8H, UINT8L, UINT8H (low and high byte variants)
#     ##                  INT16, UINT16, INT32, UINT32, INT64, UINT64 and
#     ##                  FLOAT16, FLOAT32, FLOAT64 (IEEE 754 binary representation)
#     ## scale *1,2     - (optional) factor to scale the variable with
#     ## output *1,3    - (optional) type of resulting field, can be INT64, UINT64 or FLOAT64. Defaults to FLOAT64 if
#     ##                  "scale" is provided and to the input "type" class otherwise (i.e. INT* -> INT64, etc).
#     ## measurement *1 - (optional) measurement name, defaults to the setting of the request
#     ## omit           - (optional) omit this field. Useful to leave out single values when querying many registers
#     ##                  with a single request. Defaults to "false".
#     ##
#     ## *1: These fields are ignored if field is omitted ("omit"=true)
#     ## *2: These fields are ignored for both "coil" and "discrete"-input type of registers.
#     ## *3: This field can only be "UINT16" or "BOOL" if specified for both "coil"
#     ##     and "discrete"-input type of registers. By default the fields are
#     ##     output as zero or one in UINT16 format unless "BOOL" is used.
#
#     ## Coil / discrete input example
#     fields = [
#       { address=0, name="motor1_run"},
#       { address=1, name="jog", measurement="motor"},
#       { address=2, name="motor1_stop", omit=true},
#       { address=3, name="motor1_overheating", output="BOOL"},
#     ]
#
#     [inputs.modbus.request.tags]
#       machine = "impresser"
#       location = "main building"
#
#   [[inputs.modbus.request]]
#     ## Holding example
#     ## All of those examples will result in FLOAT64 field outputs
#     slave_id = 1
#     byte_order = "DCBA"
#     register = "holding"
#     fields = [
#       { address=0, name="voltage",      type="INT16",   scale=0.1   },
#       { address=1, name="current",      type="INT32",   scale=0.001 },
#       { address=3, name="power",        type="UINT32",  omit=true   },
#       { address=5, name="energy",       type="FLOAT32", scale=0.001, measurement="W" },
#       { address=7, name="frequency",    type="UINT32",  scale=0.1   },
#       { address=8, name="power_factor", type="INT64",   scale=0.01  },
#     ]
#
#     [inputs.modbus.request.tags]
#       machine = "impresser"
#       location = "main building"
#
#   [[inputs.modbus.request]]
#     ## Input example with type conversions
#     slave_id = 1
#     byte_order = "ABCD"
#     register = "input"
#     fields = [
#       { address=0, name="rpm",         type="INT16"                   },  # will result in INT64 field
#       { address=1, name="temperature", type="INT16", scale=0.1        },  # will result in FLOAT64 field
#       { address=2, name="force",       type="INT32", output="FLOAT64" },  # will result in FLOAT64 field
#       { address=4, name="hours",       type="UINT32"                  },  # will result in UIN64 field
#     ]
#
#     [inputs.modbus.request.tags]
#       machine = "impresser"
#       location = "main building"
#
#
#   ## RS485 specific settings. Only take effect for serial controllers.
#   ## Note: This has to be at the end of the modbus configuration due to
#   ## TOML constraints.
#   # [inputs.modbus.rs485]
#     ## Delay RTS prior to sending
#     # delay_rts_before_send = "0ms"
#     ## Delay RTS after to sending
#     # delay_rts_after_send = "0ms"
#     ## Pull RTS line to high during sending
#     # rts_high_during_send = false
#     ## Pull RTS line to high after sending
#     # rts_high_after_send = false
#     ## Enabling receiving (Rx) during transmission (Tx)
#     # rx_during_tx = false
#
#   ## Enable workarounds required by some devices to work correctly
#   # [inputs.modbus.workarounds]
#     ## Pause after connect delays the first request by the specified time.
#     ## This might be necessary for (slow) devices.
#     # pause_after_connect = "0ms"
#
#     ## Pause between read requests sent to the device.
#     ## This might be necessary for (slow) serial devices.
#     # pause_between_requests = "0ms"
#
#     ## Close the connection after every gather cycle.
#     ## Usually the plugin closes the connection after a certain idle-timeout,
#     ## however, if you query a device with limited simultaneous connectivity
#     ## (e.g. serial devices) from multiple instances you might want to only
#     ## stay connected during gather and disconnect afterwards.
#     # close_connection_after_gather = false
#
#     ## Force the plugin to read each field in a separate request.
#     ## This might be necessary for devices not conforming to the spec,
#     ## see https://github.com/influxdata/telegraf/issues/12071.
#     # one_request_per_field = false
#
#     ## Enforce the starting address to be zero for the first request on
#     ## coil registers. This is necessary for some devices see
#     ## https://github.com/influxdata/telegraf/issues/8905


### Network

# # Gather metrics about network interfaces
# [[inputs.net]]
#   ## By default, telegraf gathers stats from any up interface (excluding loopback)
#   ## Setting interfaces will tell it to gather these explicit interfaces,
#   ## regardless of status. When specifying an interface, glob-style
#   ## patterns are also supported.
#   ##
#   # interfaces = ["eth*", "enp0s[0-1]", "lo"]
#   ##
#   ## On linux systems telegraf also collects protocol stats.
#   ## Setting ignore_protocol_stats to true will skip reporting of protocol metrics.
#   ##
#   # ignore_protocol_stats = false
#   ##


# # Collect response time of a TCP or UDP connection
# [[inputs.net_response]]
#   ## Protocol, must be "tcp" or "udp"
#   ## NOTE: because the "udp" protocol does not respond to requests, it requires
#   ## a send/expect string pair (see below).
#   protocol = "tcp"
#   ## Server address (default localhost)
#   address = "localhost:80"
#
#   ## Set timeout
#   # timeout = "1s"
#
#   ## Set read timeout (only used if expecting a response)
#   # read_timeout = "1s"
#
#   ## The following options are required for UDP checks. For TCP, they are
#   ## optional. The plugin will send the given string to the server and then
#   ## expect to receive the given 'expect' string back.
#   ## string sent to the server
#   # send = "ssh"
#   ## expected string in answer
#   # expect = "ssh"
#
#   ## Uncomment to remove deprecated fields; recommended for new deploys
#   # fielddrop = ["result_type", "string_found"]


# # Read TCP metrics such as established, time wait and sockets counts.
# [[inputs.netstat]]
#   # no configuration


# # Read per-mount NFS client metrics from /proc/self/mountstats
# [[inputs.nfsclient]]
#   ## Read more low-level metrics (optional, defaults to false)
#   # fullstat = false
#
#   ## List of mounts to explictly include or exclude (optional)
#   ## The pattern (Go regexp) is matched against the mount point (not the
#   ## device being mounted).  If include_mounts is set, all mounts are ignored
#   ## unless present in the list. If a mount is listed in both include_mounts
#   ## and exclude_mounts, it is excluded.  Go regexp patterns can be used.
#   # include_mounts = []
#   # exclude_mounts = []
#
#   ## List of operations to include or exclude from collecting.  This applies
#   ## only when fullstat=true.  Symantics are similar to {include,exclude}_mounts:
#   ## the default is to collect everything; when include_operations is set, only
#   ## those OPs are collected; when exclude_operations is set, all are collected
#   ## except those listed.  If include and exclude are set, the OP is excluded.
#   ## See /proc/self/mountstats for a list of valid operations; note that
#   ## NFSv3 and NFSv4 have different lists.  While it is not possible to
#   ## have different include/exclude lists for NFSv3/4, unused elements
#   ## in the list should be okay.  It is possible to have different lists
#   ## for different mountpoints:  use mulitple [[input.nfsclient]] stanzas,
#   ## with their own lists.  See "include_mounts" above, and be careful of
#   ## duplicate metrics.
#   # include_operations = []
#   # exclude_operations = []



# # Get standard NTP query metrics, requires ntpq executable.
# [[inputs.ntpq]]
#   ## Servers to query with ntpq.
#   ## If no server is given, the local machine is queried.
#   # servers = []
#
#   ## If false, set the -n ntpq flag. Can reduce metric gather time.
#   ## DEPRECATED since 1.24.0: add '-n' to 'options' instead to skip DNS lookup
#   # dns_lookup = true
#
#   ## Options to pass to the ntpq command.
#   # options = "-p"
#
#   ## Output format for the 'reach' field.
#   ## Available values are
#   ##   octal   --  output as is in octal representation e.g. 377 (default)
#   ##   decimal --  convert value to decimal representation e.g. 371 -> 249
#   ##   count   --  count the number of bits in the value. This represents
#   ##               the number of successful reaches, e.g. 37 -> 5
#   ##   ratio   --  output the ratio of successful attempts e.g. 37 -> 5/8 = 0.625
#   # reach_format = "octal"



# # Get standard NTP query metrics from OpenNTPD.
# [[inputs.openntpd]]
#   ## Run ntpctl binary with sudo.
#   # use_sudo = false
#
#   ## Location of the ntpctl binary.
#   # binary = "/usr/sbin/ntpctl"
#
#   ## Maximum time the ntpctl binary is allowed to run.
#   # timeout = "5ms"




# # Ping given url(s) and return statistics
# [[inputs.ping]]
#   ## Hosts to send ping packets to.
#   urls = ["example.org"]
#
#   ## Method used for sending pings, can be either "exec" or "native".  When set
#   ## to "exec" the systems ping command will be executed.  When set to "native"
#   ## the plugin will send pings directly.
#   ##
#   ## While the default is "exec" for backwards compatibility, new deployments
#   ## are encouraged to use the "native" method for improved compatibility and
#   ## performance.
#   # method = "exec"
#
#   ## Number of ping packets to send per interval.  Corresponds to the "-c"
#   ## option of the ping command.
#   # count = 1
#
#   ## Time to wait between sending ping packets in seconds.  Operates like the
#   ## "-i" option of the ping command.
#   # ping_interval = 1.0
#
#   ## If set, the time to wait for a ping response in seconds.  Operates like
#   ## the "-W" option of the ping command.
#   # timeout = 1.0
#
#   ## If set, the total ping deadline, in seconds.  Operates like the -w option
#   ## of the ping command.
#   # deadline = 10
#
#   ## Interface or source address to send ping from.  Operates like the -I or -S
#   ## option of the ping command.
#   # interface = ""
#
#   ## Percentiles to calculate. This only works with the native method.
#   # percentiles = [50, 95, 99]
#
#   ## Specify the ping executable binary.
#   # binary = "ping"
#
#   ## Arguments for ping command. When arguments is not empty, the command from
#   ## the binary option will be used and other options (ping_interval, timeout,
#   ## etc) will be ignored.
#   # arguments = ["-c", "3"]
#
#   ## Use only IPv6 addresses when resolving a hostname.
#   # ipv6 = false
#
#   ## Number of data bytes to be sent. Corresponds to the "-s"
#   ## option of the ping command. This only works with the native method.
#   # size = 56



# # Gather indicators from established connections, using iproute2's ss command.
# # This plugin ONLY supports non-Windows
# [[inputs.socketstat]]
#   ## ss can display information about tcp, udp, raw, unix, packet, dccp and sctp sockets
#   ## Specify here the types you want to gather
#   protocols = [ "tcp", "udp" ]
#
#   ## The default timeout of 1s for ss execution can be overridden here:
#   # timeout = "1s"


# # Sysstat metrics collector
# # This plugin ONLY supports Linux
# [[inputs.sysstat]]
#   ## Path to the sadc command.
#   #
#   ## Common Defaults:
#   ##   Debian/Ubuntu: /usr/lib/sysstat/sadc
#   ##   Arch:          /usr/lib/sa/sadc
#   ##   RHEL/CentOS:   /usr/lib64/sa/sadc
#   sadc_path = "/usr/lib/sa/sadc" # required
#
#   ## Path to the sadf command, if it is not in PATH
#   # sadf_path = "/usr/bin/sadf"
#
#   ## Activities is a list of activities, that are passed as argument to the
#   ## sadc collector utility (e.g: DISK, SNMP etc...)
#   ## The more activities that are added, the more data is collected.
#   # activities = ["DISK"]
#
#   ## Group metrics to measurements.
#   ##
#   ## If group is false each metric will be prefixed with a description
#   ## and represents itself a measurement.
#   ##
#   ## If Group is true, corresponding metrics are grouped to a single measurement.
#   # group = true
#
#   ## Options for the sadf command. The values on the left represent the sadf options and
#   ## the values on the right their description (wich are used for grouping and prefixing metrics).
#   ##
#   ## Run 'sar -h' or 'man sar' to find out the supported options for your sysstat version.
#   [inputs.sysstat.options]
#     -C = "cpu"
#     -B = "paging"
#     -b = "io"
#     -d = "disk"             # requires DISK activity
#     "-n ALL" = "network"
#     "-P ALL" = "per_cpu"
#     -q = "queue"
#     -R = "mem"
#     -r = "mem_util"
#     -S = "swap_util"
#     -u = "cpu_util"
#     -v = "inode"
#     -W = "swap"
#     -w = "task"
#   # -H = "hugepages"        # only available for newer linux distributions
#   # "-I ALL" = "interrupts" # requires INT activity
#
#   ## Device tags can be used to add additional tags for devices. For example the configuration below
#   ## adds a tag vg with value rootvg for all metrics with sda devices.
#   # [[inputs.sysstat.device_tags.sda]]
#   #  vg = "rootvg"


# # Gather systemd units state
# [[inputs.systemd_units]]
#   ## Set timeout for systemctl execution
#   # timeout = "1s"
#   #
#   ## Filter for a specific unit type, default is "service", other possible
#   ## values are "socket", "target", "device", "mount", "automount", "swap",
#   ## "timer", "path", "slice" and "scope ":
#   # unittype = "service"
#   #
#   ## Filter for a specific pattern, default is "" (i.e. all), other possible
#   ## values are valid pattern for systemctl, e.g. "a*" for all units with
#   ## names starting with "a"
#   # pattern = ""
#   ## pattern = "telegraf* influxdb*"
#   ## pattern = "a*"




# # Read metrics about temperature
# [[inputs.temp]]
#   # no configuration



# # Gather metrics from the Tomcat server status page.
# [[inputs.tomcat]]
#   ## URL of the Tomcat server status
#   # url = "http://127.0.0.1:8080/manager/status/all?XML=true"
#
#   ## HTTP Basic Auth Credentials
#   # username = "tomcat"
#   # password = "s3cret"
#
#   ## Request timeout
#   # timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Monitor UPSes connected via Network UPS Tools
# [[inputs.upsd]]
#   ## A running NUT server to connect to.
#   ## IPv6 addresses must be enclosed in brackets (e.g. "[::1]")
#   # server = "127.0.0.1"
#   # port = 3493
#   # username = "user"
#   # password = "password"
#
#   ## Force parsing numbers as floats
#   ## It is highly recommended to enable this setting to parse numbers
#   ## consistently as floats to avoid database conflicts where some numbers are
#   ## parsed as integers and others as floats.
#   # force_float = false



# # # Input plugin to counterPath Performance Counters on Windows operating systems
# # # This plugin ONLY supports Windows
# # [[inputs.win_perf_counters]]
# #   ## By default this plugin returns basic CPU and Disk statistics.
# #   ## See the README file for more examples.
# #   ## Uncomment examples below or write your own as you see fit. If the system
# #   ## being polled for data does not have the Object at startup of the Telegraf
# #   ## agent, it will not be gathered.
# #   ## Settings:
# #   # PrintValid = false # Print All matching performance counters
# #   # Whether request a timestamp along with the PerfCounter data or just use current time
# #   # UsePerfCounterTime=true
# #   # If UseWildcardsExpansion params is set to true, wildcards (partial wildcards in instance names and wildcards in counters names) in configured counter paths will be expanded
# #   # and in case of localized Windows, counter paths will be also localized. It also returns instance indexes in instance names.
# #   # If false, wildcards (not partial) in instance names will still be expanded, but instance indexes will not be returned in instance names.
# #   #UseWildcardsExpansion = false
# #   # When running on a localized version of Windows and with UseWildcardsExpansion = true, Windows will
# #   # localize object and counter names. When LocalizeWildcardsExpansion = false, use the names in object.Counters instead
# #   # of the localized names. Only Instances can have wildcards in this case. ObjectName and Counters must not have wildcards when this
# #   # setting is false.
# #   #LocalizeWildcardsExpansion = true
# #   # Period after which counters will be reread from configuration and wildcards in counter paths expanded
# #   CountersRefreshInterval="1m"
# #   ## Accepts a list of PDH error codes which are defined in pdh.go, if this error is encountered it will be ignored
# #   ## For example, you can provide "PDH_NO_DATA" to ignore performance counters with no instances
# #   ## By default no errors are ignored
# #   ## You can find the list here: https://github.com/influxdata/telegraf/blob/master/plugins/inputs/win_perf_counters/pdh.go
# #   ## e.g.: IgnoredErrors = ["PDH_NO_DATA"]
# #   # IgnoredErrors = []
# #
# #   [[inputs.win_perf_counters.object]]
# #     # Processor usage, alternative to native, reports on a per core.
# #     ObjectName = "Processor"
# #     Instances = ["*"]
# #     Counters = [
# #       "% Idle Time",
# #       "% Interrupt Time",
# #       "% Privileged Time",
# #       "% User Time",
# #       "% Processor Time",
# #       "% DPC Time",
# #     ]
# #     Measurement = "win_cpu"
# #     # Set to true to include _Total instance when querying for all (*).
# #     # IncludeTotal=false
# #     # Print out when the performance counter is missing from object, counter or instance.
# #     # WarnOnMissing = false
# #     # Gather raw values instead of formatted. Raw value is stored in the field name with the "_Raw" suffix, e.g. "Disk_Read_Bytes_sec_Raw".
# #     # UseRawValues = true
# #
# #   [[inputs.win_perf_counters.object]]
# #     # Disk times and queues
# #     ObjectName = "LogicalDisk"
# #     Instances = ["*"]
# #     Counters = [
# #       "% Idle Time",
# #       "% Disk Time",
# #       "% Disk Read Time",
# #       "% Disk Write Time",
# #       "% User Time",
# #       "% Free Space",
# #       "Current Disk Queue Length",
# #       "Free Megabytes",
# #     ]
# #     Measurement = "win_disk"
# #
# #   [[inputs.win_perf_counters.object]]
# #     ObjectName = "PhysicalDisk"
# #     Instances = ["*"]
# #     Counters = [
# #       "Disk Read Bytes/sec",
# #       "Disk Write Bytes/sec",
# #       "Current Disk Queue Length",
# #       "Disk Reads/sec",
# #       "Disk Writes/sec",
# #       "% Disk Time",
# #       "% Disk Read Time",
# #       "% Disk Write Time",
# #     ]
# #     Measurement = "win_diskio"
# #
# #   [[inputs.win_perf_counters.object]]
# #     ObjectName = "Network Interface"
# #     Instances = ["*"]
# #     Counters = [
# #       "Bytes Received/sec",
# #       "Bytes Sent/sec",
# #       "Packets Received/sec",
# #       "Packets Sent/sec",
# #       "Packets Received Discarded",
# #       "Packets Outbound Discarded",
# #       "Packets Received Errors",
# #       "Packets Outbound Errors",
# #     ]
# #     Measurement = "win_net"
# #
# #
# #   [[inputs.win_perf_counters.object]]
# #     ObjectName = "System"
# #     Counters = [
# #       "Context Switches/sec",
# #       "System Calls/sec",
# #       "Processor Queue Length",
# #       "System Up Time",
# #     ]
# #     Instances = ["------"]
# #     Measurement = "win_system"
# #
# #   [[inputs.win_perf_counters.object]]
# #     # Example counterPath where the Instance portion must be removed to get data back,
# #     # such as from the Memory object.
# #     ObjectName = "Memory"
# #     Counters = [
# #       "Available Bytes",
# #       "Cache Faults/sec",
# #       "Demand Zero Faults/sec",
# #       "Page Faults/sec",
# #       "Pages/sec",
# #       "Transition Faults/sec",
# #       "Pool Nonpaged Bytes",
# #       "Pool Paged Bytes",
# #       "Standby Cache Reserve Bytes",
# #       "Standby Cache Normal Priority Bytes",
# #       "Standby Cache Core Bytes",
# #     ]
# #     Instances = ["------"] # Use 6 x - to remove the Instance bit from the counterPath.
# #     Measurement = "win_mem"
# #
# #   [[inputs.win_perf_counters.object]]
# #     # Example query where the Instance portion must be removed to get data back,
# #     # such as from the Paging File object.
# #     ObjectName = "Paging File"
# #     Counters = [
# #       "% Usage",
# #     ]
# #     Instances = ["_Total"]
# #     Measurement = "win_swap"


# # Input plugin to report Windows services info.
# # This plugin ONLY supports Windows
# [[inputs.win_services]]
#   ## Names of the services to monitor. Leave empty to monitor all the available services on the host. Globs accepted. Case sensitive.
#   service_names = [
#     "LanmanServer",
#     "TermService",
#     "Win*",
#   ]
#   excluded_service_names = ['WinRM'] # optional, list of service names to exclude


# # Input plugin to query Windows Management Instrumentation
# # This plugin ONLY supports Windows
# [[inputs.win_wmi]]
#   [[inputs.win_wmi.query]]
#     # a string representing the WMI namespace to be queried
#     namespace = "root\\cimv2"
#     # a string representing the WMI class to be queried
#     class_name = "Win32_Volume"
#     # an array of strings representing the properties of the WMI class to be queried
#     properties = ["Name", "Capacity", "FreeSpace"]
#     # a string specifying a WHERE clause to use as a filter for the WQL
#     filter = 'NOT Name LIKE "\\\\?\\%"'
#     # WMI class properties which should be considered tags instead of fields
#     tag_properties = ["Name"]



# # Monitor wifi signal strength and quality
# # This plugin ONLY supports Linux
# [[inputs.wireless]]
#   ## Sets 'proc' directory path
#   ## If not specified, then default is /proc
#   # host_proc = "/proc"


# # Reads metrics from a SSL certificate
# [[inputs.x509_cert]]
#   ## List certificate sources, support wildcard expands for files
#   ## Prefix your entry with 'file://' if you intend to use relative paths
#   sources = ["tcp://example.org:443", "https://influxdata.com:443",
#             "smtp://mail.localhost:25", "udp://127.0.0.1:4433",
#             "/etc/ssl/certs/ssl-cert-snakeoil.pem",
#             "/etc/mycerts/*.mydomain.org.pem", "file:///path/to/*.pem"]
#
#   ## Timeout for SSL connection
#   # timeout = "5s"
#
#   ## Pass a different name into the TLS request (Server Name Indication).
#   ## This is synonymous with tls_server_name, and only one of the two
#   ## options may be specified at one time.
#   ##   example: server_name = "myhost.example.org"
#   # server_name = "myhost.example.org"
#
#   ## Only output the leaf certificates and omit the root ones.
#   # exclude_root_certs = false
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   # tls_server_name = "myhost.example.org"
#
#   ## Set the proxy URL
#   # use_proxy = true
#   # proxy_url = "http://localhost:8888"



# # Read metrics of ZFS from arcstats, zfetchstats, vdev_cache_stats, pools and datasets
# # This plugin ONLY supports Linux & FreeBSD
# [[inputs.zfs]]
#   ## ZFS kstat path. Ignored on FreeBSD
#   ## If not specified, then default is:
#   # kstatPath = "/proc/spl/kstat/zfs"
#
#   ## By default, telegraf gather all zfs stats
#   ## Override the stats list using the kstatMetrics array:
#   ## For FreeBSD, the default is:
#   # kstatMetrics = ["arcstats", "zfetchstats", "vdev_cache_stats"]
#   ## For Linux, the default is:
#   # kstatMetrics = ["abdstats", "arcstats", "dnodestats", "dbufcachestats",
#   #     "dmu_tx", "fm", "vdev_mirror_stats", "zfetchstats", "zil"]
#
#   ## By default, don't gather zpool stats
#   # poolMetrics = false
#
#   ## By default, don't gather dataset stats
#   # datasetMetrics = false



###############################################################################
#                            SERVICE INPUT PLUGINS                            #
###############################################################################




# # Ingests files in a directory and then moves them to a target directory.
# [[inputs.directory_monitor]]
#   ## The directory to monitor and read files from (including sub-directories if "recursive" is true).
#   directory = ""
#   #
#   ## The directory to move finished files to (maintaining directory hierachy from source).
#   finished_directory = ""
#   #
#   ## Setting recursive to true will make the plugin recursively walk the directory and process all sub-directories.
#   # recursive = false
#   #
#   ## The directory to move files to upon file error.
#   ## If not provided, erroring files will stay in the monitored directory.
#   # error_directory = ""
#   #
#   ## The amount of time a file is allowed to sit in the directory before it is picked up.
#   ## This time can generally be low but if you choose to have a very large file written to the directory and it's potentially slow,
#   ## set this higher so that the plugin will wait until the file is fully copied to the directory.
#   # directory_duration_threshold = "50ms"
#   #
#   ## A list of the only file names to monitor, if necessary. Supports regex. If left blank, all files are ingested.
#   # files_to_monitor = ["^.*\.csv"]
#   #
#   ## A list of files to ignore, if necessary. Supports regex.
#   # files_to_ignore = [".DS_Store"]
#   #
#   ## Maximum lines of the file to process that have not yet be written by the
#   ## output. For best throughput set to the size of the output's metric_buffer_limit.
#   ## Warning: setting this number higher than the output's metric_buffer_limit can cause dropped metrics.
#   # max_buffered_metrics = 10000
#   #
#   ## The maximum amount of file paths to queue up for processing at once, before waiting until files are processed to find more files.
#   ## Lowering this value will result in *slightly* less memory use, with a potential sacrifice in speed efficiency, if absolutely necessary.
#   # file_queue_size = 100000
#   #
#   ## Name a tag containing the name of the file the data was parsed from.  Leave empty
#   ## to disable. Cautious when file name variation is high, this can increase the cardinality
#   ## significantly. Read more about cardinality here:
#   ## https://docs.influxdata.com/influxdb/cloud/reference/glossary/#series-cardinality
#   # file_tag = ""
#   #
#   ## Specify if the file can be read completely at once or if it needs to be read line by line (default).
#   ## Possible values: "line-by-line", "at-once"
#   # parse_method = "line-by-line"
#   #
#   ## The dataformat to be read from the files.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"


# # Read logging output from the Docker engine
# [[inputs.docker_log]]
#   ## Docker Endpoint
#   ##   To use TCP, set endpoint = "tcp://[ip]:[port]"
#   ##   To use environment variables (ie, docker-machine), set endpoint = "ENV"
#   # endpoint = "unix:///var/run/docker.sock"
#
#   ## When true, container logs are read from the beginning; otherwise reading
#   ## begins at the end of the log. If state-persistence is enabled for Telegraf,
#   ## the reading continues at the last previously processed timestamp.
#   # from_beginning = false
#
#   ## Timeout for Docker API calls.
#   # timeout = "5s"
#
#   ## Containers to include and exclude. Globs accepted.
#   ## Note that an empty array for both will include all containers
#   # container_name_include = []
#   # container_name_exclude = []
#
#   ## Container states to include and exclude. Globs accepted.
#   ## When empty only containers in the "running" state will be captured.
#   # container_state_include = []
#   # container_state_exclude = []
#
#   ## docker labels to include and exclude as tags.  Globs accepted.
#   ## Note that an empty array for both will include all labels as tags
#   # docker_label_include = []
#   # docker_label_exclude = []
#
#   ## Set the source tag for the metrics to the container ID hostname, eg first 12 chars
#   source_tag = false
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false




# # Run executable as long-running input plugin
# [[inputs.execd]]
#   ## One program to run as daemon.
#   ## NOTE: process and each argument should each be their own string
#   command = ["telegraf-smartctl", "-d", "/dev/sda"]
#
#   ## Environment variables
#   ## Array of "key=value" pairs to pass as environment variables
#   ## e.g. "KEY=value", "USERNAME=John Doe",
#   ## "LD_LIBRARY_PATH=/opt/custom/lib64:/usr/local/libs"
#   # environment = []
#
#   ## Define how the process is signaled on each collection interval.
#   ## Valid values are:
#   ##   "none"    : Do not signal anything. (Recommended for service inputs)
#   ##               The process must output metrics by itself.
#   ##   "STDIN"   : Send a newline on STDIN. (Recommended for gather inputs)
#   ##   "SIGHUP"  : Send a HUP signal. Not available on Windows. (not recommended)
#   ##   "SIGUSR1" : Send a USR1 signal. Not available on Windows.
#   ##   "SIGUSR2" : Send a USR2 signal. Not available on Windows.
#   signal = "none"
#
#   ## Delay before the process is restarted after an unexpected termination
#   restart_delay = "10s"
#
#   ## Buffer size used to read from the command output stream
#   ## Optional parameter. Default is 64 Kib, minimum is 16 bytes
#   # buffer_size = "64Kib"
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"




#  ## DEPRECATED: The "http_listener" plugin is deprecated in version 1.9.0, has been renamed to 'influxdb_listener', use 'inputs.influxdb_listener' or 'inputs.http_listener_v2' instead.
# # Accept metrics over InfluxDB 1.x HTTP API
# [[inputs.influxdb_listener]]
#   ## Address and port to host HTTP listener on
#   service_address = ":8186"
#
#   ## maximum duration before timing out read of the request
#   read_timeout = "10s"
#   ## maximum duration before timing out write of the response
#   write_timeout = "10s"
#
#   ## Maximum allowed HTTP request body size in bytes.
#   ## 0 means to use the default of 32MiB.
#   max_body_size = 0
#
#   ## Maximum line size allowed to be sent in bytes.
#   ##   deprecated in 1.14; parser now handles lines of unlimited length and option is ignored
#   # max_line_size = 0
#
#   ## Set one or more allowed client CA certificate file names to
#   ## enable mutually authenticated TLS connections
#   tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Add service certificate and key
#   tls_cert = "/etc/telegraf/cert.pem"
#   tls_key = "/etc/telegraf/key.pem"
#
#   ## Optional tag name used to store the database name.
#   ## If the write has a database in the query string then it will be kept in this tag name.
#   ## This tag can be used in downstream outputs.
#   ## The default value of nothing means it will be off and the database will not be recorded.
#   ## If you have a tag that is the same as the one specified below, and supply a database,
#   ## the tag will be overwritten with the database supplied.
#   # database_tag = ""
#
#   ## If set the retention policy specified in the write query will be added as
#   ## the value of this tag name.
#   # retention_policy_tag = ""
#
#   ## Optional username and password to accept for HTTP basic authentication.
#   ## You probably want to make sure you have TLS configured above for this.
#   # basic_username = "foobar"
#   # basic_password = "barfoo"
#
#   ## Influx line protocol parser
#   ## 'internal' is the default. 'upstream' is a newer parser that is faster
#   ## and more memory efficient.
#   # parser_type = "internal"


# # Generic HTTP write listener
# [[inputs.http_listener_v2]]
#   ## Address and port to host HTTP listener on
#   service_address = ":8080"
#
#   ## Paths to listen to.
#   # paths = ["/telegraf"]
#
#   ## Save path as http_listener_v2_path tag if set to true
#   # path_tag = false
#
#   ## HTTP methods to accept.
#   # methods = ["POST", "PUT"]
#
#   ## Optional HTTP headers
#   ## These headers are applied to the server that is listening for HTTP
#   ## requests and included in responses.
#   # http_headers = {"HTTP_HEADER" = "TAG_NAME"}
#
#   ## maximum duration before timing out read of the request
#   # read_timeout = "10s"
#   ## maximum duration before timing out write of the response
#   # write_timeout = "10s"
#
#   ## Maximum allowed http request body size in bytes.
#   ## 0 means to use the default of 524,288,000 bytes (500 mebibytes)
#   # max_body_size = "500MB"
#
#   ## Part of the request to consume.  Available options are "body" and
#   ## "query".
#   # data_source = "body"
#
#   ## Set one or more allowed client CA certificate file names to
#   ## enable mutually authenticated TLS connections
#   # tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Add service certificate and key
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#
#   ## Minimal TLS version accepted by the server
#   # tls_min_version = "TLS12"
#
#   ## Optional username and password to accept for HTTP basic authentication.
#   ## You probably want to make sure you have TLS configured above for this.
#   # basic_username = "foobar"
#   # basic_password = "barfoo"
#
#   ## Optional setting to map http headers into tags
#   ## If the http header is not present on the request, no corresponding tag will be added
#   ## If multiple instances of the http header are present, only the first value will be used
#   # http_header_tags = {"HTTP_HEADER" = "TAG_NAME"}
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"


# # Accept metrics over InfluxDB 1.x HTTP API
# [[inputs.influxdb_listener]]
#   ## Address and port to host HTTP listener on
#   service_address = ":8186"
#
#   ## maximum duration before timing out read of the request
#   read_timeout = "10s"
#   ## maximum duration before timing out write of the response
#   write_timeout = "10s"
#
#   ## Maximum allowed HTTP request body size in bytes.
#   ## 0 means to use the default of 32MiB.
#   max_body_size = 0
#
#   ## Maximum line size allowed to be sent in bytes.
#   ##   deprecated in 1.14; parser now handles lines of unlimited length and option is ignored
#   # max_line_size = 0
#
#   ## Set one or more allowed client CA certificate file names to
#   ## enable mutually authenticated TLS connections
#   tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Add service certificate and key
#   tls_cert = "/etc/telegraf/cert.pem"
#   tls_key = "/etc/telegraf/key.pem"
#
#   ## Optional tag name used to store the database name.
#   ## If the write has a database in the query string then it will be kept in this tag name.
#   ## This tag can be used in downstream outputs.
#   ## The default value of nothing means it will be off and the database will not be recorded.
#   ## If you have a tag that is the same as the one specified below, and supply a database,
#   ## the tag will be overwritten with the database supplied.
#   # database_tag = ""
#
#   ## If set the retention policy specified in the write query will be added as
#   ## the value of this tag name.
#   # retention_policy_tag = ""
#
#   ## Optional username and password to accept for HTTP basic authentication.
#   ## You probably want to make sure you have TLS configured above for this.
#   # basic_username = "foobar"
#   # basic_password = "barfoo"
#
#   ## Influx line protocol parser
#   ## 'internal' is the default. 'upstream' is a newer parser that is faster
#   ## and more memory efficient.
#   # parser_type = "internal"


# # Accept metrics over InfluxDB 2.x HTTP API
# [[inputs.influxdb_v2_listener]]
#   ## Address and port to host InfluxDB listener on
#   ## (Double check the port. Could be 9999 if using OSS Beta)
#   service_address = ":8086"
#
#   ## Maximum duration before timing out read of the request
#   # read_timeout = "10s"
#   ## Maximum duration before timing out write of the response
#   # write_timeout = "10s"
#
#   ## Maximum allowed HTTP request body size in bytes.
#   ## 0 means to use the default of 32MiB.
#   # max_body_size = "32MiB"
#
#   ## Optional tag to determine the bucket.
#   ## If the write has a bucket in the query string then it will be kept in this tag name.
#   ## This tag can be used in downstream outputs.
#   ## The default value of nothing means it will be off and the database will not be recorded.
#   # bucket_tag = ""
#
#   ## Set one or more allowed client CA certificate file names to
#   ## enable mutually authenticated TLS connections
#   # tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Add service certificate and key
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#
#   ## Optional token to accept for HTTP authentication.
#   ## You probably want to make sure you have TLS configured above for this.
#   # token = "some-long-shared-secret-token"
#
#   ## Influx line protocol parser
#   ## 'internal' is the default. 'upstream' is a newer parser that is faster
#   ## and more memory efficient.
#   # parser_type = "internal"


# # Intel Performance Monitoring Unit plugin exposes Intel PMU metrics available through Linux Perf subsystem
# # This plugin ONLY supports Linux on amd64
# [[inputs.intel_pmu]]
#   ## List of filesystem locations of JSON files that contain PMU event definitions.
#   event_definitions = ["/var/cache/pmu/GenuineIntel-6-55-4-core.json", "/var/cache/pmu/GenuineIntel-6-55-4-uncore.json"]
#
#   ## List of core events measurement entities. There can be more than one core_events sections.
#   [[inputs.intel_pmu.core_events]]
#     ## List of events to be counted. Event names shall match names from event_definitions files.
#     ## Single entry can contain name of the event (case insensitive) augmented with config options and perf modifiers.
#     ## If absent, all core events from provided event_definitions are counted skipping unresolvable ones.
#     events = ["INST_RETIRED.ANY", "CPU_CLK_UNHALTED.THREAD_ANY:config1=0x4043200000000k"]
#
#     ## Limits the counting of events to core numbers specified.
#     ## If absent, events are counted on all cores.
#     ## Single "0", multiple "0,1,2" and range "0-2" notation is supported for each array element.
#     ##   example: cores = ["0,2", "4", "12-16"]
#     cores = ["0"]
#
#     ## Indicator that plugin shall attempt to run core_events.events as a single perf group.
#     ## If absent or set to false, each event is counted individually. Defaults to false.
#     ## This limits the number of events that can be measured to a maximum of available hardware counters per core.
#     ## Could vary depending on type of event, use of fixed counters.
#     # perf_group = false
#
#     ## Optionally set a custom tag value that will be added to every measurement within this events group.
#     ## Can be applied to any group of events, unrelated to perf_group setting.
#     # events_tag = ""
#
#   ## List of uncore event measurement entities. There can be more than one uncore_events sections.
#   [[inputs.intel_pmu.uncore_events]]
#     ## List of events to be counted. Event names shall match names from event_definitions files.
#     ## Single entry can contain name of the event (case insensitive) augmented with config options and perf modifiers.
#     ## If absent, all uncore events from provided event_definitions are counted skipping unresolvable ones.
#     events = ["UNC_CHA_CLOCKTICKS", "UNC_CHA_TOR_OCCUPANCY.IA_MISS"]
#
#     ## Limits the counting of events to specified sockets.
#     ## If absent, events are counted on all sockets.
#     ## Single "0", multiple "0,1" and range "0-1" notation is supported for each array element.
#     ##   example: sockets = ["0-2"]
#     sockets = ["0"]
#
#     ## Indicator that plugin shall provide an aggregated value for multiple units of same type distributed in an uncore.
#     ## If absent or set to false, events for each unit are exposed as separate metric. Defaults to false.
#     # aggregate_uncore_units = false
#
#     ## Optionally set a custom tag value that will be added to every measurement within this events group.
#     # events_tag = ""


# # Read Intel RDT metrics
# # This plugin ONLY supports non-Windows
# [[inputs.intel_rdt]]
#   ## Optionally set sampling interval to Nx100ms.
#   ## This value is propagated to pqos tool. Interval format is defined by pqos itself.
#   ## If not provided or provided 0, will be set to 10 = 10x100ms = 1s.
#   # sampling_interval = "10"
#
#   ## Optionally specify the path to pqos executable.
#   ## If not provided, auto discovery will be performed.
#   # pqos_path = "/usr/local/bin/pqos"
#
#   ## Optionally specify if IPC and LLC_Misses metrics shouldn't be propagated.
#   ## If not provided, default value is false.
#   # shortened_metrics = false
#
#   ## Specify the list of groups of CPU core(s) to be provided as pqos input.
#   ## Mandatory if processes aren't set and forbidden if processes are specified.
#   ## e.g. ["0-3", "4,5,6"] or ["1-3,4"]
#   # cores = ["0-3"]
#
#   ## Specify the list of processes for which Metrics will be collected.
#   ## Mandatory if cores aren't set and forbidden if cores are specified.
#   ## e.g. ["qemu", "pmd"]
#   # processes = ["process"]
#
#   ## Specify if the pqos process should be called with sudo.
#   ## Mandatory if the telegraf process does not run as root.
#   # use_sudo = false




# # Read metrics from one or many pgbouncer servers
# [[inputs.pgbouncer]]
#   ## specify address via a url matching:
#   ##   postgres://[pqgotest[:password]]@host:port[/dbname]\
#   ##       ?sslmode=[disable|verify-ca|verify-full]
#   ## or a simple string:
#   ##   host=localhost port=5432 user=pqgotest password=... sslmode=... dbname=app_production
#   ##
#   ## All connection parameters are optional.
#   ##
#   address = "host=localhost user=pgbouncer sslmode=disable"


# # Read metrics from one or many postgresql servers
# [[inputs.postgresql]]
#   ## Specify address via a url matching:
#   ##   postgres://[pqgotest[:password]]@localhost[/dbname]?sslmode=[disable|verify-ca|verify-full]&statement_timeout=...
#   ## or a simple string:
#   ##   host=localhost user=pqgotest password=... sslmode=... dbname=app_production
#   ## Users can pass the path to the socket as the host value to use a socket
#   ## connection (e.g. `/var/run/postgresql`).
#   ##
#   ## All connection parameters are optional.
#   ##
#   ## Without the dbname parameter, the driver will default to a database
#   ## with the same name as the user. This dbname is just for instantiating a
#   ## connection with the server and doesn't restrict the databases we are trying
#   ## to grab metrics for.
#   ##
#   address = "host=localhost user=postgres sslmode=disable"
#
#   ## A custom name for the database that will be used as the "server" tag in the
#   ## measurement output. If not specified, a default one generated from
#   ## the connection address is used.
#   # outputaddress = "db01"
#
#   ## connection configuration.
#   ## maxlifetime - specify the maximum lifetime of a connection.
#   ## default is forever (0s)
#   ##
#   ## Note that this does not interrupt queries, the lifetime will not be enforced
#   ## whilst a query is running
#   # max_lifetime = "0s"
#
#   ## A  list of databases to explicitly ignore.  If not specified, metrics for all
#   ## databases are gathered.  Do NOT use with the 'databases' option.
#   # ignored_databases = ["postgres", "template0", "template1"]
#
#   ## A list of databases to pull metrics about. If not specified, metrics for all
#   ## databases are gathered.  Do NOT use with the 'ignored_databases' option.
#   # databases = ["app_production", "testing"]
#
#   ## Whether to use prepared statements when connecting to the database.
#   ## This should be set to false when connecting through a PgBouncer instance
#   ## with pool_mode set to transaction.
#   prepared_statements = true


# # Read metrics from one or many postgresql servers
# [[inputs.postgresql_extensible]]
#   # specify address via a url matching:
#   # postgres://[pqgotest[:password]]@host:port[/dbname]?sslmode=...&statement_timeout=...
#   # or a simple string:
#   #   host=localhost port=5432 user=pqgotest password=... sslmode=... dbname=app_production
#   #
#   # All connection parameters are optional.
#   # Without the dbname parameter, the driver will default to a database
#   # with the same name as the user. This dbname is just for instantiating a
#   # connection with the server and doesn't restrict the databases we are trying
#   # to grab metrics for.
#   #
#   address = "host=localhost user=postgres sslmode=disable"
#
#   ## A list of databases to pull metrics about.
#   ## deprecated in 1.22.3; use the sqlquery option to specify database to use
#   # databases = ["app_production", "testing"]
#
#   ## Whether to use prepared statements when connecting to the database.
#   ## This should be set to false when connecting through a PgBouncer instance
#   ## with pool_mode set to transaction.
#   prepared_statements = true
#
#   # Define the toml config where the sql queries are stored
#   # The script option can be used to specify the .sql file path.
#   # If script and sqlquery options specified at same time, sqlquery will be used
#   #
#   # the tagvalue field is used to define custom tags (separated by comas).
#   # the query is expected to return columns which match the names of the
#   # defined tags. The values in these columns must be of a string-type,
#   # a number-type or a blob-type.
#   #
#   # The timestamp field is used to override the data points timestamp value. By
#   # default, all rows inserted with current time. By setting a timestamp column,
#   # the row will be inserted with that column's value.
#   #
#   # Structure :
#   # [[inputs.postgresql_extensible.query]]
#   #   sqlquery string
#   #   version string
#   #   withdbname boolean
#   #   tagvalue string (coma separated)
#   #   timestamp string
#   [[inputs.postgresql_extensible.query]]
#     sqlquery="SELECT * FROM pg_stat_database where datname"
#     version=901
#     withdbname=false
#     tagvalue=""
#   [[inputs.postgresql_extensible.query]]
#     script="your_sql-filepath.sql"
#     version=901
#     withdbname=false
#     tagvalue=""




# # Read metrics from one or many redis servers
# [[inputs.redis]]
#   ## specify servers via a url matching:
#   ##  [protocol://][:password]@address[:port]
#   ##  e.g.
#   ##    tcp://localhost:6379
#   ##    tcp://:password@192.168.99.100
#   ##    unix:///var/run/redis.sock
#   ##
#   ## If no servers are specified, then localhost is used as the host.
#   ## If no port is specified, 6379 is used
#   servers = ["tcp://localhost:6379"]
#
#   ## Optional. Specify redis commands to retrieve values
#   # [[inputs.redis.commands]]
#   #   # The command to run where each argument is a separate element
#   #   command = ["get", "sample-key"]
#   #   # The field to store the result in
#   #   field = "sample-key-value"
#   #   # The type of the result
#   #   # Can be "string", "integer", or "float"
#   #   type = "string"
#
#   ## specify server password
#   # password = "s#cr@t%"
#
#   ## specify username for ACL auth (Redis 6.0+)
#   # username = "default"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = true



# # Receive SNMP traps
# [[inputs.snmp_trap]]
#   ## Transport, local address, and port to listen on.  Transport must
#   ## be "udp://".  Omit local address to listen on all interfaces.
#   ##   example: "udp://127.0.0.1:1234"
#   ##
#   ## Special permissions may be required to listen on a port less than
#   ## 1024.  See README.md for details
#   ##
#   # service_address = "udp://:162"
#   ##
#   ## Path to mib files
#   ## Used by the gosmi translator.
#   ## To add paths when translating with netsnmp, use the MIBDIRS environment variable
#   # path = ["/usr/share/snmp/mibs"]
#   ##
#   ## Deprecated in 1.20.0; no longer running snmptranslate
#   ## Timeout running snmptranslate command
#   # timeout = "5s"
#   ## Snmp version
#   # version = "2c"
#   ## SNMPv3 authentication and encryption options.
#   ##
#   ## Security Name.
#   # sec_name = "myuser"
#   ## Authentication protocol; one of "MD5", "SHA" or "".
#   # auth_protocol = "MD5"
#   ## Authentication password.
#   # auth_password = "pass"
#   ## Security Level; one of "noAuthNoPriv", "authNoPriv", or "authPriv".
#   # sec_level = "authNoPriv"
#   ## Privacy protocol used for encrypted messages; one of "DES", "AES", "AES192", "AES192C", "AES256", "AES256C" or "".
#   # priv_protocol = ""
#   ## Privacy password used for encrypted messages.
#   # priv_password = ""


# # Generic socket listener capable of handling multiple socket types.
# [[inputs.socket_listener]]
#   ## URL to listen on
#   # service_address = "tcp://:8094"
#   # service_address = "tcp://127.0.0.1:http"
#   # service_address = "tcp4://:8094"
#   # service_address = "tcp6://:8094"
#   # service_address = "tcp6://[2001:db8::1]:8094"
#   # service_address = "udp://:8094"
#   # service_address = "udp4://:8094"
#   # service_address = "udp6://:8094"
#   # service_address = "unix:///tmp/telegraf.sock"
#   # service_address = "unixgram:///tmp/telegraf.sock"
#
#   ## Change the file mode bits on unix sockets.  These permissions may not be
#   ## respected by some platforms, to safely restrict write permissions it is best
#   ## to place the socket into a directory that has previously been created
#   ## with the desired permissions.
#   ##   ex: socket_mode = "777"
#   # socket_mode = ""
#
#   ## Maximum number of concurrent connections.
#   ## Only applies to stream sockets (e.g. TCP).
#   ## 0 (default) is unlimited.
#   # max_connections = 1024
#
#   ## Read timeout.
#   ## Only applies to stream sockets (e.g. TCP).
#   ## 0 (default) is unlimited.
#   # read_timeout = "30s"
#
#   ## Optional TLS configuration.
#   ## Only applies to stream sockets (e.g. TCP).
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key  = "/etc/telegraf/key.pem"
#   ## Enables client authentication if set.
#   # tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Maximum socket buffer size (in bytes when no unit specified).
#   ## For stream sockets, once the buffer fills up, the sender will start backing up.
#   ## For datagram sockets, once the buffer fills up, metrics will start dropping.
#   ## Defaults to the OS default.
#   # read_buffer_size = "64KiB"
#
#   ## Period between keep alive probes.
#   ## Only applies to TCP sockets.
#   ## 0 disables keep alive probes.
#   ## Defaults to the OS configuration.
#   # keep_alive_period = "5m"
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   # data_format = "influx"
#
#   ## Content encoding for message payloads, can be set to "gzip" to or
#   ## "identity" to apply no encoding.
#   # content_encoding = "identity"
#
#   ## Maximum size of decoded packet.
#   ## Acceptable units are B, KiB, KB, MiB, MB...
#   ## Without quotes and units, interpreted as size in bytes.
#   # max_decompression_size = "500MB"
#
#   ## Message splitting strategy and corresponding settings for stream sockets
#   ## (tcp, tcp4, tcp6, unix or unixpacket). The setting is ignored for packet
#   ## listeners such as udp.
#   ## Available strategies are:
#   ##   newline         -- split at newlines (default)
#   ##   null            -- split at null bytes
#   ##   delimiter       -- split at delimiter byte-sequence in hex-format
#   ##                      given in `splitting_delimiter`
#   ##   fixed length    -- split after number of bytes given in `splitting_length`
#   ##   variable length -- split depending on length information received in the
#   ##                      data. The length field information is specified in
#   ##                      `splitting_length_field`.
#   # splitting_strategy = "newline"
#
#   ## Delimiter used to split received data to messages consumed by the parser.
#   ## The delimiter is a hex byte-sequence marking the end of a message
#   ## e.g. "0x0D0A", "x0d0a" or "0d0a" marks a Windows line-break (CR LF).
#   ## The value is case-insensitive and can be specifed with "0x" or "x" prefix
#   ## or withou.
#   ## Note: This setting is only used for splitting_strategy = "delimiter".
#   # splitting_delimiter = ""
#
#   ## Fixed length of a message in bytes.
#   ## Note: This setting is only used for splitting_strategy = "fixed length".
#   # splitting_length = 0
#
#   ## Specification of the length field contained in the data to split messages
#   ## with variable length. The specification contains the following fields:
#   ##  offset        -- start of length field in bytes from begin of data
#   ##  bytes         -- length of length field in bytes
#   ##  endianness    -- endianness of the value, either "be" for big endian or
#   ##                   "le" for little endian
#   ##  header_length -- total length of header to be skipped when passing
#   ##                   data on to the parser. If zero (default), the header
#   ##                   is passed on to the parser together with the message.
#   ## Note: This setting is only used for splitting_strategy = "variable length".
#   # splitting_length_field = {offset = 0, bytes = 0, endianness = "be", header_length = 0}


# # Read metrics from SQL queries
# [[inputs.sql]]
#   ## Database Driver
#   ## See https://github.com/influxdata/telegraf/blob/master/docs/SQL_DRIVERS_INPUT.md for
#   ## a list of supported drivers.
#   driver = "mysql"
#
#   ## Data source name for connecting
#   ## The syntax and supported options depends on selected driver.
#   dsn = "username:password@mysqlserver:3307/dbname?param=value"
#
#   ## Timeout for any operation
#   ## Note that the timeout for queries is per query not per gather.
#   # timeout = "5s"
#
#   ## Connection time limits
#   ## By default the maximum idle time and maximum lifetime of a connection is unlimited, i.e. the connections
#   ## will not be closed automatically. If you specify a positive time, the connections will be closed after
#   ## idleing or existing for at least that amount of time, respectively.
#   # connection_max_idle_time = "0s"
#   # connection_max_life_time = "0s"
#
#   ## Connection count limits
#   ## By default the number of open connections is not limited and the number of maximum idle connections
#   ## will be inferred from the number of queries specified. If you specify a positive number for any of the
#   ## two options, connections will be closed when reaching the specified limit. The number of idle connections
#   ## will be clipped to the maximum number of connections limit if any.
#   # connection_max_open = 0
#   # connection_max_idle = auto
#
#   ## Specifies plugin behavior regarding disconnected servers
#   ## Available choices :
#   ##   - error: telegraf will return an error on startup if one the servers is unreachable
#   ##   - ignore: telegraf will ignore unreachable servers on both startup and gather
#   # disconnected_servers_behavior = "error"
#
#   [[inputs.sql.query]]
#     ## Query to perform on the server
#     query="SELECT user,state,latency,score FROM Scoreboard WHERE application > 0"
#     ## Alternatively to specifying the query directly you can select a file here containing the SQL query.
#     ## Only one of 'query' and 'query_script' can be specified!
#     # query_script = "/path/to/sql/script.sql"
#
#     ## Name of the measurement
#     ## In case both measurement and 'measurement_col' are given, the latter takes precedence.
#     # measurement = "sql"
#
#     ## Column name containing the name of the measurement
#     ## If given, this will take precedence over the 'measurement' setting. In case a query result
#     ## does not contain the specified column, we fall-back to the 'measurement' setting.
#     # measurement_column = ""
#
#     ## Column name containing the time of the measurement
#     ## If ommited, the time of the query will be used.
#     # time_column = ""
#
#     ## Format of the time contained in 'time_col'
#     ## The time must be 'unix', 'unix_ms', 'unix_us', 'unix_ns', or a golang time format.
#     ## See https://golang.org/pkg/time/#Time.Format for details.
#     # time_format = "unix"
#
#     ## Column names containing tags
#     ## An empty include list will reject all columns and an empty exclude list will not exclude any column.
#     ## I.e. by default no columns will be returned as tag and the tags are empty.
#     # tag_columns_include = []
#     # tag_columns_exclude = []
#
#     ## Column names containing fields (explicit types)
#     ## Convert the given columns to the corresponding type. Explicit type conversions take precedence over
#     ## the automatic (driver-based) conversion below.
#     ## NOTE: Columns should not be specified for multiple types or the resulting type is undefined.
#     # field_columns_float = []
#     # field_columns_int = []
#     # field_columns_uint = []
#     # field_columns_bool = []
#     # field_columns_string = []
#
#     ## Column names containing fields (automatic types)
#     ## An empty include list is equivalent to '[*]' and all returned columns will be accepted. An empty
#     ## exclude list will not exclude any column. I.e. by default all columns will be returned as fields.
#     ## NOTE: We rely on the database driver to perform automatic datatype conversion.
#     # field_columns_include = []
#     # field_columns_exclude = []


# # Read metrics from Microsoft SQL Server
# [[inputs.sqlserver]]
#   ## Specify instances to monitor with a list of connection strings.
#   ## All connection parameters are optional.
#   ## By default, the host is localhost, listening on default port, TCP 1433.
#   ##   for Windows, the user is the currently running AD user (SSO).
#   ##   See https://github.com/microsoft/go-mssqldb for detailed connection
#   ##   parameters, in particular, tls connections can be created like so:
#   ##   "encrypt=true;certificate=<cert>;hostNameInCertificate=<SqlServer host fqdn>"
#   servers = [
#     "Server=192.168.1.10;Port=1433;User Id=<user>;Password=<pw>;app name=telegraf;log=1;",
#   ]
#
#   ## Timeout for query execution operation
#   ## Note that the timeout for queries is per query not per gather.
#   ## 0 value means no timeout
#   # query_timeout = "0s"
#
#   ## Authentication method
#   ## valid methods: "connection_string", "AAD"
#   # auth_method = "connection_string"
#
#   ## "database_type" enables a specific set of queries depending on the database type. If specified, it replaces azuredb = true/false and query_version = 2
#   ## In the config file, the sql server plugin section should be repeated each with a set of servers for a specific database_type.
#   ## Possible values for database_type are - "SQLServer" or "AzureSQLDB" or "AzureSQLManagedInstance" or "AzureSQLPool"
#   database_type = "SQLServer"
#
#   ## A list of queries to include. If not specified, all the below listed queries are used.
#   include_query = []
#
#   ## A list of queries to explicitly ignore.
#   exclude_query = ["SQLServerAvailabilityReplicaStates", "SQLServerDatabaseReplicaStates"]
#
#   ## Queries enabled by default for database_type = "SQLServer" are -
#   ## SQLServerPerformanceCounters, SQLServerWaitStatsCategorized, SQLServerDatabaseIO, SQLServerProperties, SQLServerMemoryClerks,
#   ## SQLServerSchedulers, SQLServerRequests, SQLServerVolumeSpace, SQLServerCpu, SQLServerAvailabilityReplicaStates, SQLServerDatabaseReplicaStates,
#   ## SQLServerRecentBackups
#
#   ## Queries enabled by default for database_type = "AzureSQLDB" are -
#   ## AzureSQLDBResourceStats, AzureSQLDBResourceGovernance, AzureSQLDBWaitStats, AzureSQLDBDatabaseIO, AzureSQLDBServerProperties,
#   ## AzureSQLDBOsWaitstats, AzureSQLDBMemoryClerks, AzureSQLDBPerformanceCounters, AzureSQLDBRequests, AzureSQLDBSchedulers
#
#   ## Queries enabled by default for database_type = "AzureSQLManagedInstance" are -
#   ## AzureSQLMIResourceStats, AzureSQLMIResourceGovernance, AzureSQLMIDatabaseIO, AzureSQLMIServerProperties, AzureSQLMIOsWaitstats,
#   ## AzureSQLMIMemoryClerks, AzureSQLMIPerformanceCounters, AzureSQLMIRequests, AzureSQLMISchedulers
#
#   ## Queries enabled by default for database_type = "AzureSQLPool" are -
#   ## AzureSQLPoolResourceStats, AzureSQLPoolResourceGovernance, AzureSQLPoolDatabaseIO, AzureSQLPoolWaitStats,
#   ## AzureSQLPoolMemoryClerks, AzureSQLPoolPerformanceCounters, AzureSQLPoolSchedulers
#
#   ## Queries enabled by default for database_type = "AzureArcSQLManagedInstance" are -
#   ## AzureSQLMIDatabaseIO, AzureSQLMIServerProperties, AzureSQLMIOsWaitstats,
#   ## AzureSQLMIMemoryClerks, AzureSQLMIPerformanceCounters, AzureSQLMIRequests, AzureSQLMISchedulers
#
#   ## Following are old config settings
#   ## You may use them only if you are using the earlier flavor of queries, however it is recommended to use
#   ## the new mechanism of identifying the database_type there by use it's corresponding queries
#
#   ## Optional parameter, setting this to 2 will use a new version
#   ## of the collection queries that break compatibility with the original
#   ## dashboards.
#   ## Version 2 - is compatible from SQL Server 2012 and later versions and also for SQL Azure DB
#   # query_version = 2
#
#   ## If you are using AzureDB, setting this to true will gather resource utilization metrics
#   # azuredb = false
#
#   ## Toggling this to true will emit an additional metric called "sqlserver_telegraf_health".
#   ## This metric tracks the count of attempted queries and successful queries for each SQL instance specified in "servers".
#   ## The purpose of this metric is to assist with identifying and diagnosing any connectivity or query issues.
#   ## This setting/metric is optional and is disabled by default.
#   # health_metric = false
#
#   ## Possible queries accross different versions of the collectors
#   ## Queries enabled by default for specific Database Type
#
#   ## database_type =  AzureSQLDB  by default collects the following queries
#   ## - AzureSQLDBWaitStats
#   ## - AzureSQLDBResourceStats
#   ## - AzureSQLDBResourceGovernance
#   ## - AzureSQLDBDatabaseIO
#   ## - AzureSQLDBServerProperties
#   ## - AzureSQLDBOsWaitstats
#   ## - AzureSQLDBMemoryClerks
#   ## - AzureSQLDBPerformanceCounters
#   ## - AzureSQLDBRequests
#   ## - AzureSQLDBSchedulers
#
#   ## database_type =  AzureSQLManagedInstance by default collects the following queries
#   ## - AzureSQLMIResourceStats
#   ## - AzureSQLMIResourceGovernance
#   ## - AzureSQLMIDatabaseIO
#   ## - AzureSQLMIServerProperties
#   ## - AzureSQLMIOsWaitstats
#   ## - AzureSQLMIMemoryClerks
#   ## - AzureSQLMIPerformanceCounters
#   ## - AzureSQLMIRequests
#   ## - AzureSQLMISchedulers
#
#   ## database_type =  AzureSQLPool by default collects the following queries
#   ## - AzureSQLPoolResourceStats
#   ## - AzureSQLPoolResourceGovernance
#   ## - AzureSQLPoolDatabaseIO
#   ## - AzureSQLPoolOsWaitStats,
#   ## - AzureSQLPoolMemoryClerks
#   ## - AzureSQLPoolPerformanceCounters
#   ## - AzureSQLPoolSchedulers
#
#   ## database_type =  SQLServer by default collects the following queries
#   ## - SQLServerPerformanceCounters
#   ## - SQLServerWaitStatsCategorized
#   ## - SQLServerDatabaseIO
#   ## - SQLServerProperties
#   ## - SQLServerMemoryClerks
#   ## - SQLServerSchedulers
#   ## - SQLServerRequests
#   ## - SQLServerVolumeSpace
#   ## - SQLServerCpu
#   ## - SQLServerRecentBackups
#   ## and following as optional (if mentioned in the include_query list)
#   ## - SQLServerAvailabilityReplicaStates
#   ## - SQLServerDatabaseReplicaStates
#
#   ## Version 2 by default collects the following queries
#   ## Version 2 is being deprecated, please consider using database_type.
#   ## - PerformanceCounters
#   ## - WaitStatsCategorized
#   ## - DatabaseIO
#   ## - ServerProperties
#   ## - MemoryClerk
#   ## - Schedulers
#   ## - SqlRequests
#   ## - VolumeSpace
#   ## - Cpu
#
#   ## Version 1 by default collects the following queries
#   ## Version 1 is deprecated, please consider using database_type.
#   ## - PerformanceCounters
#   ## - WaitStatsCategorized
#   ## - CPUHistory
#   ## - DatabaseIO
#   ## - DatabaseSize
#   ## - DatabaseStats
#   ## - DatabaseProperties
#   ## - MemoryClerk
#   ## - VolumeSpace
#   ## - PerformanceMetrics


# # Statsd Server
# [[inputs.statsd]]
#   ## Protocol, must be "tcp", "udp4", "udp6" or "udp" (default=udp)
#   protocol = "udp"
#
#   ## MaxTCPConnection - applicable when protocol is set to tcp (default=250)
#   max_tcp_connections = 250
#
#   ## Enable TCP keep alive probes (default=false)
#   tcp_keep_alive = false
#
#   ## Specifies the keep-alive period for an active network connection.
#   ## Only applies to TCP sockets and will be ignored if tcp_keep_alive is false.
#   ## Defaults to the OS configuration.
#   # tcp_keep_alive_period = "2h"
#
#   ## Address and port to host UDP listener on
#   service_address = ":8125"
#
#   ## The following configuration options control when telegraf clears it's cache
#   ## of previous values. If set to false, then telegraf will only clear it's
#   ## cache when the daemon is restarted.
#   ## Reset gauges every interval (default=true)
#   delete_gauges = true
#   ## Reset counters every interval (default=true)
#   delete_counters = true
#   ## Reset sets every interval (default=true)
#   delete_sets = true
#   ## Reset timings & histograms every interval (default=true)
#   delete_timings = true
#
#   ## Enable aggregation temporality adds temporality=delta or temporality=commulative tag, and
#   ## start_time field, which adds the start time of the metric accumulation.
#   ## You should use this when using OpenTelemetry output.
#   # enable_aggregation_temporality = false
#
#   ## Percentiles to calculate for timing & histogram stats.
#   percentiles = [50.0, 90.0, 99.0, 99.9, 99.95, 100.0]
#
#   ## separator to use between elements of a statsd metric
#   metric_separator = "_"
#
#   ## Parses tags in the datadog statsd format
#   ## http://docs.datadoghq.com/guides/dogstatsd/
#   ## deprecated in 1.10; use datadog_extensions option instead
#   parse_data_dog_tags = false
#
#   ## Parses extensions to statsd in the datadog statsd format
#   ## currently supports metrics and datadog tags.
#   ## http://docs.datadoghq.com/guides/dogstatsd/
#   datadog_extensions = false
#
#   ## Parses distributions metric as specified in the datadog statsd format
#   ## https://docs.datadoghq.com/developers/metrics/types/?tab=distribution#definition
#   datadog_distributions = false
#
#   ## Statsd data translation templates, more info can be read here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/TEMPLATE_PATTERN.md
#   # templates = [
#   #     "cpu.* measurement*"
#   # ]
#
#   ## Number of UDP messages allowed to queue up, once filled,
#   ## the statsd server will start dropping packets
#   allowed_pending_messages = 10000
#
#   ## Number of worker threads used to parse the incoming messages.
#   # number_workers_threads = 5
#
#   ## Number of timing/histogram values to track per-measurement in the
#   ## calculation of percentiles. Raising this limit increases the accuracy
#   ## of percentiles but also increases the memory usage and cpu time.
#   percentile_limit = 1000
#
#   ## Maximum socket buffer size in bytes, once the buffer fills up, metrics
#   ## will start dropping.  Defaults to the OS default.
#   # read_buffer_size = 65535
#
#   ## Max duration (TTL) for each metric to stay cached/reported without being updated.
#   # max_ttl = "10h"
#
#   ## Sanitize name method
#   ## By default, telegraf will pass names directly as they are received.
#   ## However, upstream statsd now does sanitization of names which can be
#   ## enabled by using the "upstream" method option. This option will a) replace
#   ## white space with '_', replace '/' with '-', and remove charachters not
#   ## matching 'a-zA-Z_\-0-9\.;='.
#   #sanitize_name_method = ""




# [[inputs.syslog]]
#   ## Protocol, address and port to host the syslog receiver.
#   ## If no host is specified, then localhost is used.
#   ## If no port is specified, 6514 is used (RFC5425#section-4.1).
#   ##   ex: server = "tcp://localhost:6514"
#   ##       server = "udp://:6514"
#   ##       server = "unix:///var/run/telegraf-syslog.sock"
#   ## When using tcp, consider using 'tcp4' or 'tcp6' to force the usage of IPv4
#   ## or IPV6 respectively. There are cases, where when not specified, a system
#   ## may force an IPv4 mapped IPv6 address.
#   server = "tcp://:6514"
#
#   ## TLS Config
#   # tls_allowed_cacerts = ["/etc/telegraf/ca.pem"]
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#
#   ## Period between keep alive probes.
#   ## 0 disables keep alive probes.
#   ## Defaults to the OS configuration.
#   ## Only applies to stream sockets (e.g. TCP).
#   # keep_alive_period = "5m"
#
#   ## Maximum number of concurrent connections (default = 0).
#   ## 0 means unlimited.
#   ## Only applies to stream sockets (e.g. TCP).
#   # max_connections = 1024
#
#   ## Read timeout is the maximum time allowed for reading a single message (default = 5s).
#   ## 0 means unlimited.
#   # read_timeout = "5s"
#
#   ## The framing technique with which it is expected that messages are transported (default = "octet-counting").
#   ## Whether the messages come using the octect-counting (RFC5425#section-4.3.1, RFC6587#section-3.4.1),
#   ## or the non-transparent framing technique (RFC6587#section-3.4.2).
#   ## Must be one of "octect-counting", "non-transparent".
#   # framing = "octet-counting"
#
#   ## The trailer to be expected in case of non-transparent framing (default = "LF").
#   ## Must be one of "LF", or "NUL".
#   # trailer = "LF"
#
#   ## Whether to parse in best effort mode or not (default = false).
#   ## By default best effort parsing is off.
#   # best_effort = false
#
#   ## The RFC standard to use for message parsing
#   ## By default RFC5424 is used. RFC3164 only supports UDP transport (no streaming support)
#   ## Must be one of "RFC5424", or "RFC3164".
#   # syslog_standard = "RFC5424"
#
#   ## Character to prepend to SD-PARAMs (default = "_").
#   ## A syslog message can contain multiple parameters and multiple identifiers within structured data section.
#   ## Eg., [id1 name1="val1" name2="val2"][id2 name1="val1" nameA="valA"]
#   ## For each combination a field is created.
#   ## Its name is created concatenating identifier, sdparam_separator, and parameter name.
#   # sdparam_separator = "_"


# # Parse the new lines appended to a file
# [[inputs.tail]]
#   ## File names or a pattern to tail.
#   ## These accept standard unix glob matching rules, but with the addition of
#   ## ** as a "super asterisk". ie:
#   ##   "/var/log/**.log"  -> recursively find all .log files in /var/log
#   ##   "/var/log/*/*.log" -> find all .log files with a parent dir in /var/log
#   ##   "/var/log/apache.log" -> just tail the apache log file
#   ##   "/var/log/log[!1-2]*  -> tail files without 1-2
#   ##   "/var/log/log[^1-2]*  -> identical behavior as above
#   ## See https://github.com/gobwas/glob for more examples
#   ##
#   files = ["/var/mymetrics.out"]
#
#   ## Read file from beginning.
#   # from_beginning = false
#
#   ## Whether file is a named pipe
#   # pipe = false
#
#   ## Method used to watch for file updates.  Can be either "inotify" or "poll".
#   # watch_method = "inotify"
#
#   ## Maximum lines of the file to process that have not yet be written by the
#   ## output.  For best throughput set based on the number of metrics on each
#   ## line and the size of the output's metric_batch_size.
#   # max_undelivered_lines = 1000
#
#   ## Character encoding to use when interpreting the file contents.  Invalid
#   ## characters are replaced using the unicode replacement character.  When set
#   ## to the empty string the data is not decoded to text.
#   ##   ex: character_encoding = "utf-8"
#   ##       character_encoding = "utf-16le"
#   ##       character_encoding = "utf-16be"
#   ##       character_encoding = ""
#   # character_encoding = ""
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#
#   ## Set the tag that will contain the path of the tailed file. If you don't want this tag, set it to an empty string.
#   # path_tag = "path"
#
#   ## Filters to apply to files before generating metrics
#   ## "ansi_color" removes ANSI colors
#   # filters = []
#
#   ## multiline parser/codec
#   ## https://www.elastic.co/guide/en/logstash/2.4/plugins-filters-multiline.html
#   #[inputs.tail.multiline]
#     ## The pattern should be a regexp which matches what you believe to be an indicator that the field is part of an event consisting of multiple lines of log data.
#     #pattern = "^\s"
#
#     ## The field's value must be previous or next and indicates the relation to the
#     ## multi-line event.
#     #match_which_line = "previous"
#
#     ## The invert_match can be true or false (defaults to false).
#     ## If true, a message not matching the pattern will constitute a match of the multiline filter and the what will be applied. (vice-versa is also true)
#     #invert_match = false
#
#     ## The handling method for quoted text (defaults to 'ignore').
#     ## The following methods are available:
#     ##   ignore  -- do not consider quotation (default)
#     ##   single-quotes -- consider text quoted by single quotes (')
#     ##   double-quotes -- consider text quoted by double quotes (")
#     ##   backticks     -- consider text quoted by backticks (`)
#     ## When handling quotes, escaped quotes (e.g. \") are handled correctly.
#     #quotation = "ignore"
#
#     ## The preserve_newline option can be true or false (defaults to false).
#     ## If true, the newline character is preserved for multiline elements,
#     ## this is useful to preserve message-structure e.g. for logging outputs.
#     #preserve_newline = false
#
#     #After the specified timeout, this plugin sends the multiline event even if no new pattern is found to start a new event. The default is 5s.
#     #timeout = 5s


#  ## DEPRECATED: The "tcp_listener" plugin is deprecated in version 1.3.0 and will be removed in 1.30.0, use 'inputs.socket_listener' instead.
# # Generic TCP listener
# [[inputs.tcp_listener]]
#   # socket_listener plugin
#   # see https://github.com/influxdata/telegraf/tree/master/plugins/inputs/socket_listener


#  ## DEPRECATED: The "udp_listener" plugin is deprecated in version 1.3.0 and will be removed in 1.30.0, use 'inputs.socket_listener' instead.
# # Generic UDP listener
# [[inputs.udp_listener]]
#   # see https://github.com/influxdata/telegraf/tree/master/plugins/inputs/socket_listener


# -# Read metrics from one or many vCenters
# [[inputs.vsphere]]
#   ## List of vCenter URLs to be monitored. These three lines must be uncommented
#   ## and edited for the plugin to work.
#   vcenters = [ "https://vcenter.local/sdk" ]
#   username = "user@corp.local"
#   password = "secret"
#
#   ## VMs
#   ## Typical VM metrics (if omitted or empty, all metrics are collected)
#   # vm_include = [ "/*/vm/**"] # Inventory path to VMs to collect (by default all are collected)
#   # vm_exclude = [] # Inventory paths to exclude
#   vm_metric_include = [
#     "cpu.demand.average",
#     "cpu.idle.summation",
#     "cpu.latency.average",
#     "cpu.readiness.average",
#     "cpu.ready.summation",
#     "cpu.run.summation",
#     "cpu.usagemhz.average",
#     "cpu.used.summation",
#     "cpu.wait.summation",
#     "mem.active.average",
#     "mem.granted.average",
#     "mem.latency.average",
#     "mem.swapin.average",
#     "mem.swapinRate.average",
#     "mem.swapout.average",
#     "mem.swapoutRate.average",
#     "mem.usage.average",
#     "mem.vmmemctl.average",
#     "net.bytesRx.average",
#     "net.bytesTx.average",
#     "net.droppedRx.summation",
#     "net.droppedTx.summation",
#     "net.usage.average",
#     "power.power.average",
#     "virtualDisk.numberReadAveraged.average",
#     "virtualDisk.numberWriteAveraged.average",
#     "virtualDisk.read.average",
#     "virtualDisk.readOIO.latest",
#     "virtualDisk.throughput.usage.average",
#     "virtualDisk.totalReadLatency.average",
#     "virtualDisk.totalWriteLatency.average",
#     "virtualDisk.write.average",
#     "virtualDisk.writeOIO.latest",
#     "sys.uptime.latest",
#   ]
#   # vm_metric_exclude = [] ## Nothing is excluded by default
#   # vm_instances = true ## true by default
#
#   ## Hosts
#   ## Typical host metrics (if omitted or empty, all metrics are collected)
#   # host_include = [ "/*/host/**"] # Inventory path to hosts to collect (by default all are collected)
#   # host_exclude [] # Inventory paths to exclude
#   host_metric_include = [
#     "cpu.coreUtilization.average",
#     "cpu.costop.summation",
#     "cpu.demand.average",
#     "cpu.idle.summation",
#     "cpu.latency.average",
#     "cpu.readiness.average",
#     "cpu.ready.summation",
#     "cpu.swapwait.summation",
#     "cpu.usage.average",
#     "cpu.usagemhz.average",
#     "cpu.used.summation",
#     "cpu.utilization.average",
#     "cpu.wait.summation",
#     "disk.deviceReadLatency.average",
#     "disk.deviceWriteLatency.average",
#     "disk.kernelReadLatency.average",
#     "disk.kernelWriteLatency.average",
#     "disk.numberReadAveraged.average",
#     "disk.numberWriteAveraged.average",
#     "disk.read.average",
#     "disk.totalReadLatency.average",
#     "disk.totalWriteLatency.average",
#     "disk.write.average",
#     "mem.active.average",
#     "mem.latency.average",
#     "mem.state.latest",
#     "mem.swapin.average",
#     "mem.swapinRate.average",
#     "mem.swapout.average",
#     "mem.swapoutRate.average",
#     "mem.totalCapacity.average",
#     "mem.usage.average",
#     "mem.vmmemctl.average",
#     "net.bytesRx.average",
#     "net.bytesTx.average",
#     "net.droppedRx.summation",
#     "net.droppedTx.summation",
#     "net.errorsRx.summation",
#     "net.errorsTx.summation",
#     "net.usage.average",
#     "power.power.average",
#     "storageAdapter.numberReadAveraged.average",
#     "storageAdapter.numberWriteAveraged.average",
#     "storageAdapter.read.average",
#     "storageAdapter.write.average",
#     "sys.uptime.latest",
#   ]
#     ## Collect IP addresses? Valid values are "ipv4" and "ipv6"
#   # ip_addresses = ["ipv6", "ipv4" ]
#
#   # host_metric_exclude = [] ## Nothing excluded by default
#   # host_instances = true ## true by default
#
#
#   ## Clusters
#   # cluster_include = [ "/*/host/**"] # Inventory path to clusters to collect (by default all are collected)
#   # cluster_exclude = [] # Inventory paths to exclude
#   # cluster_metric_include = [] ## if omitted or empty, all metrics are collected
#   # cluster_metric_exclude = [] ## Nothing excluded by default
#   # cluster_instances = false ## false by default
#
#   ## Resource Pools
#   # resource_pool_include = [ "/*/host/**"] # Inventory path to resource pools to collect (by default all are collected)
#   # resource_pool_exclude = [] # Inventory paths to exclude
#   # resource_pool_metric_include = [] ## if omitted or empty, all metrics are collected
#   # resource_pool_metric_exclude = [] ## Nothing excluded by default
#   # resource_pool_instances = false ## false by default
#
#   ## Datastores
#   # datastore_include = [ "/*/datastore/**"] # Inventory path to datastores to collect (by default all are collected)
#   # datastore_exclude = [] # Inventory paths to exclude
#   # datastore_metric_include = [] ## if omitted or empty, all metrics are collected
#   # datastore_metric_exclude = [] ## Nothing excluded by default
#   # datastore_instances = false ## false by default
#
#   ## Datacenters
#   # datacenter_include = [ "/*/host/**"] # Inventory path to clusters to collect (by default all are collected)
#   # datacenter_exclude = [] # Inventory paths to exclude
#   datacenter_metric_include = [] ## if omitted or empty, all metrics are collected
#   datacenter_metric_exclude = [ "*" ] ## Datacenters are not collected by default.
#   # datacenter_instances = false ## false by default
#
#   ## VSAN
#   # vsan_metric_include = [] ## if omitted or empty, all metrics are collected
#   # vsan_metric_exclude = [ "*" ] ## vSAN are not collected by default.
#   ## Whether to skip verifying vSAN metrics against the ones from GetSupportedEntityTypes API.
#   # vsan_metric_skip_verify = false ## false by default.
#
#   ## Plugin Settings
#   ## separator character to use for measurement and field names (default: "_")
#   # separator = "_"
#
#   ## number of objects to retrieve per query for realtime resources (vms and hosts)
#   ## set to 64 for vCenter 5.5 and 6.0 (default: 256)
#   # max_query_objects = 256
#
#   ## number of metrics to retrieve per query for non-realtime resources (clusters and datastores)
#   ## set to 64 for vCenter 5.5 and 6.0 (default: 256)
#   # max_query_metrics = 256
#
#   ## number of go routines to use for collection and discovery of objects and metrics
#   # collect_concurrency = 1
#   # discover_concurrency = 1
#
#   ## the interval before (re)discovering objects subject to metrics collection (default: 300s)
#   # object_discovery_interval = "300s"
#
#   ## timeout applies to any of the api request made to vcenter
#   # timeout = "60s"
#
#   ## When set to true, all samples are sent as integers. This makes the output
#   ## data types backwards compatible with Telegraf 1.9 or lower. Normally all
#   ## samples from vCenter, with the exception of percentages, are integer
#   ## values, but under some conditions, some averaging takes place internally in
#   ## the plugin. Setting this flag to "false" will send values as floats to
#   ## preserve the full precision when averaging takes place.
#   # use_int_samples = true
#
#   ## Custom attributes from vCenter can be very useful for queries in order to slice the
#   ## metrics along different dimension and for forming ad-hoc relationships. They are disabled
#   ## by default, since they can add a considerable amount of tags to the resulting metrics. To
#   ## enable, simply set custom_attribute_exclude to [] (empty set) and use custom_attribute_include
#   ## to select the attributes you want to include.
#   ## By default, since they can add a considerable amount of tags to the resulting metrics. To
#   ## enable, simply set custom_attribute_exclude to [] (empty set) and use custom_attribute_include
#   ## to select the attributes you want to include.
#   # custom_attribute_include = []
#   # custom_attribute_exclude = ["*"]
#
#   ## The number of vSphere 5 minute metric collection cycles to look back for non-realtime metrics. In
#   ## some versions (6.7, 7.0 and possible more), certain metrics, such as cluster metrics, may be reported
#   ## with a significant delay (>30min). If this happens, try increasing this number. Please note that increasing
#   ## it too much may cause performance issues.
#   # metric_lookback = 3
#
#   ## Optional SSL Config
#   # ssl_ca = "/path/to/cafile"
#   # ssl_cert = "/path/to/certfile"
#   # ssl_key = "/path/to/keyfile"
#   ## Use SSL but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## The Historical Interval value must match EXACTLY the interval in the daily
#   # "Interval Duration" found on the VCenter server under Configure > General > Statistics > Statistic intervals
#   # historical_interval = "5m"
#
#   ## Specifies plugin behavior regarding disconnected servers
#   ## Available choices :
#   ##   - error: telegraf will return an error on startup if one the servers is unreachable
#   ##   - ignore: telegraf will ignore unreachable servers on both startup and gather
#   # disconnected_servers_behavior = "error"




# # Input plugin to collect Windows Event Log messages
# # This plugin ONLY supports Windows
# [[inputs.win_eventlog]]
#   ## Telegraf should have Administrator permissions to subscribe for some
#   ## Windows Events channels (e.g. System log)
#
#   ## LCID (Locale ID) for event rendering
#   ## 1033 to force English language
#   ## 0 to use default Windows locale
#   # locale = 0
#
#   ## Name of eventlog, used only if xpath_query is empty
#   ## Example: "Application"
#   # eventlog_name = ""
#
#   ## xpath_query can be in defined short form like "Event/System[EventID=999]"
#   ## or you can form a XML Query. Refer to the Consuming Events article:
#   ## https://docs.microsoft.com/en-us/windows/win32/wes/consuming-events
#   ## XML query is the recommended form, because it is most flexible
#   ## You can create or debug XML Query by creating Custom View in Windows Event Viewer
#   ## and then copying resulting XML here
#   xpath_query = '''
#   <QueryList>
#     <Query Id="0" Path="Security">
#       <Select Path="Security">*</Select>
#       <Suppress Path="Security">*[System[( (EventID &gt;= 5152 and EventID &lt;= 5158) or EventID=5379 or EventID=4672)]]</Suppress>
#     </Query>
#     <Query Id="1" Path="Application">
#       <Select Path="Application">*[System[(Level &lt; 4)]]</Select>
#     </Query>
#     <Query Id="2" Path="Windows PowerShell">
#       <Select Path="Windows PowerShell">*[System[(Level &lt; 4)]]</Select>
#     </Query>
#     <Query Id="3" Path="System">
#       <Select Path="System">*</Select>
#     </Query>
#     <Query Id="4" Path="Setup">
#       <Select Path="Setup">*</Select>
#     </Query>
#   </QueryList>
#   '''
#
#   ## When true, event logs are read from the beginning; otherwise only future
#   ## events will be logged.
#   # from_beginning = false
#
#   # Process UserData XML to fields, if this node exists in Event XML
#   # process_userdata = true
#
#   # Process EventData XML to fields, if this node exists in Event XML
#   # process_eventdata = true
#
#   ## Separator character to use for unrolled XML Data field names
#   # separator = "_"
#
#   ## Get only first line of Message field. For most events first line is
#   ## usually more than enough
#   # only_first_line_of_message = true
#
#   ## Parse timestamp from TimeCreated.SystemTime event field.
#   ## Will default to current time of telegraf processing on parsing error or if
#   ## set to false
#   # timestamp_from_event = true
#
#   ## System field names:
#   ##   "Source", "EventID", "Version", "Level", "Task", "Opcode", "Keywords",
#   ##   "TimeCreated", "EventRecordID", "ActivityID", "RelatedActivityID",
#   ##   "ProcessID", "ThreadID", "ProcessName", "Channel", "Computer", "UserID",
#   ##   "UserName", "Message", "LevelText", "TaskText", "OpcodeText"
#   ##
#   ## In addition to System, Data fields can be unrolled from additional XML
#   ## nodes in event. Human-readable representation of those nodes is formatted
#   ## into event Message field, but XML is more machine-parsable
#
#   ## Event fields to include as tags
#   ## The values below are included by default.
#   ## Globbing supported (e.g. "Level*" matches both "Level" and "LevelText")
#   # event_tags = ["Source", "EventID", "Level", "LevelText", "Task", "TaskText", "Opcode", "OpcodeText", "Keywords", "Channel", "Computer"]
#
#   ## Event fields to include
#   ## All fields are sent by default.
#   ## Globbing supported (e.g. "Level*" matches both "Level" and "LevelText")
#   # event_fields = ["*"]
#
#   ## Event fields to exclude
#   ## Note that if you exclude all fields then no metrics are produced. A valid
#   ## metric includes at least one field.
#   ## Globbing supported (e.g. "Level*" matches both "Level" and "LevelText")
#   # exclude_fields = []
#
#   ## Event fields to exclude if their value is empty or equals to zero
#   ## The values below are included by default.
#   ## Globbing supported (e.g. "Level*" matches both "Level" and "LevelText")
#   # exclude_empty = ["Task", "Opcode", "*ActivityID", "UserID"]
